/* dconf-schema.c generated by valac 0.18.0, the Vala compiler
 * generated from dconf-schema.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SCHEMA_KEY (schema_key_get_type ())
#define SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_KEY, SchemaKey))
#define SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_KEY, SchemaKeyClass))
#define IS_SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_KEY))
#define IS_SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_KEY))
#define SCHEMA_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_KEY, SchemaKeyClass))

typedef struct _SchemaKey SchemaKey;
typedef struct _SchemaKeyClass SchemaKeyClass;
typedef struct _SchemaKeyPrivate SchemaKeyPrivate;

#define TYPE_SCHEMA (schema_get_type ())
#define SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA, Schema))
#define SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA, SchemaClass))
#define IS_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA))
#define IS_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA))
#define SCHEMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA, SchemaClass))

typedef struct _Schema Schema;
typedef struct _SchemaClass SchemaClass;

#define TYPE_SCHEMA_VALUE_RANGE (schema_value_range_get_type ())
#define SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange))
#define SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))
#define IS_SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE_RANGE))
#define IS_SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE_RANGE))
#define SCHEMA_VALUE_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))

typedef struct _SchemaValueRange SchemaValueRange;
typedef struct _SchemaValueRangeClass SchemaValueRangeClass;

#define TYPE_SCHEMA_CHOICE (schema_choice_get_type ())
#define SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_CHOICE, SchemaChoice))
#define SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))
#define IS_SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_CHOICE))
#define IS_SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_CHOICE))
#define SCHEMA_CHOICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))

typedef struct _SchemaChoice SchemaChoice;
typedef struct _SchemaChoiceClass SchemaChoiceClass;
#define _schema_unref0(var) ((var == NULL) ? NULL : (var = (schema_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _schema_value_range_unref0(var) ((var == NULL) ? NULL : (var = (schema_value_range_unref (var), NULL)))
#define __g_list_free__schema_choice_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__schema_choice_unref0_ (var), NULL)))
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ParamSpecSchemaKey ParamSpecSchemaKey;

#define TYPE_SCHEMA_VALUE (schema_value_get_type ())
#define SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE, SchemaValue))
#define SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE, SchemaValueClass))
#define IS_SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE))
#define IS_SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE))
#define SCHEMA_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE, SchemaValueClass))

typedef struct _SchemaValue SchemaValue;
typedef struct _SchemaValueClass SchemaValueClass;
typedef struct _SchemaValuePrivate SchemaValuePrivate;
typedef struct _SchemaChoicePrivate SchemaChoicePrivate;
typedef struct _ParamSpecSchemaChoice ParamSpecSchemaChoice;
typedef struct _SchemaValueRangePrivate SchemaValueRangePrivate;
typedef struct _ParamSpecSchemaValueRange ParamSpecSchemaValueRange;

#define TYPE_SCHEMA_ENUM (schema_enum_get_type ())
#define SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_ENUM, SchemaEnum))
#define SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_ENUM, SchemaEnumClass))
#define IS_SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_ENUM))
#define IS_SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_ENUM))
#define SCHEMA_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_ENUM, SchemaEnumClass))

typedef struct _SchemaEnum SchemaEnum;
typedef struct _SchemaEnumClass SchemaEnumClass;
typedef struct _SchemaEnumPrivate SchemaEnumPrivate;

#define TYPE_SCHEMA_LIST (schema_list_get_type ())
#define SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_LIST, SchemaList))
#define SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_LIST, SchemaListClass))
#define IS_SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_LIST))
#define IS_SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_LIST))
#define SCHEMA_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_LIST, SchemaListClass))

typedef struct _SchemaList SchemaList;
typedef struct _SchemaListClass SchemaListClass;
#define _schema_list_unref0(var) ((var == NULL) ? NULL : (var = (schema_list_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ParamSpecSchemaEnum ParamSpecSchemaEnum;

#define TYPE_SCHEMA_FLAGS (schema_flags_get_type ())
#define SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_FLAGS, SchemaFlags))
#define SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))
#define IS_SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_FLAGS))
#define IS_SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_FLAGS))
#define SCHEMA_FLAGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))

typedef struct _SchemaFlags SchemaFlags;
typedef struct _SchemaFlagsClass SchemaFlagsClass;
typedef struct _SchemaFlagsPrivate SchemaFlagsPrivate;
typedef struct _ParamSpecSchemaFlags ParamSpecSchemaFlags;
typedef struct _SchemaPrivate SchemaPrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _schema_key_unref0(var) ((var == NULL) ? NULL : (var = (schema_key_unref (var), NULL)))
typedef struct _ParamSpecSchema ParamSpecSchema;
typedef struct _SchemaListPrivate SchemaListPrivate;
#define __g_list_free__schema_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__schema_unref0_ (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _schema_enum_unref0(var) ((var == NULL) ? NULL : (var = (schema_enum_unref (var), NULL)))
#define _schema_flags_unref0(var) ((var == NULL) ? NULL : (var = (schema_flags_unref (var), NULL)))
typedef struct _ParamSpecSchemaList ParamSpecSchemaList;

struct _SchemaKey {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaKeyPrivate * priv;
	Schema* schema;
	gchar* name;
	gchar* type;
	GVariant* default_value;
	SchemaValueRange* range;
	SchemaValueRange* type_range;
	GList* choices;
	gchar* enum_name;
	gchar* summary;
	gchar* description;
	gchar* gettext_domain;
};

struct _SchemaKeyClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaKey *self);
};

struct _ParamSpecSchemaKey {
	GParamSpec parent_instance;
};

struct _SchemaValue {
	GObject parent_instance;
	SchemaValuePrivate * priv;
	guint index;
	gchar* nick;
	gint value;
};

struct _SchemaValueClass {
	GObjectClass parent_class;
};

struct _SchemaChoice {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaChoicePrivate * priv;
	gchar* name;
	GVariant* value;
};

struct _SchemaChoiceClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaChoice *self);
};

struct _ParamSpecSchemaChoice {
	GParamSpec parent_instance;
};

struct _SchemaValueRange {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaValueRangePrivate * priv;
	GVariant* min;
	GVariant* max;
};

struct _SchemaValueRangeClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaValueRange *self);
};

struct _ParamSpecSchemaValueRange {
	GParamSpec parent_instance;
};

struct _SchemaEnum {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaEnumPrivate * priv;
	SchemaList* list;
	gchar* id;
	GList* values;
};

struct _SchemaEnumClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaEnum *self);
};

struct _ParamSpecSchemaEnum {
	GParamSpec parent_instance;
};

struct _SchemaFlags {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaFlagsPrivate * priv;
	SchemaList* list;
	gchar* id;
	GList* values;
};

struct _SchemaFlagsClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaFlags *self);
};

struct _ParamSpecSchemaFlags {
	GParamSpec parent_instance;
};

struct _Schema {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaPrivate * priv;
	SchemaList* list;
	gchar* id;
	gchar* path;
	GHashTable* keys;
};

struct _SchemaClass {
	GTypeClass parent_class;
	void (*finalize) (Schema *self);
};

struct _ParamSpecSchema {
	GParamSpec parent_instance;
};

struct _SchemaList {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaListPrivate * priv;
	GList* schemas;
	GHashTable* keys;
	GHashTable* enums;
	GHashTable* flags;
};

struct _SchemaListClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaList *self);
};

struct _ParamSpecSchemaList {
	GParamSpec parent_instance;
};


static gpointer schema_key_parent_class = NULL;
static gpointer schema_value_parent_class = NULL;
static gpointer schema_choice_parent_class = NULL;
static gpointer schema_value_range_parent_class = NULL;
static gpointer schema_enum_parent_class = NULL;
static gpointer schema_flags_parent_class = NULL;
static gpointer schema_parent_class = NULL;
static gpointer schema_list_parent_class = NULL;

gpointer schema_key_ref (gpointer instance);
void schema_key_unref (gpointer instance);
GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_key (GValue* value, gpointer v_object);
void value_take_schema_key (GValue* value, gpointer v_object);
gpointer value_get_schema_key (const GValue* value);
GType schema_key_get_type (void) G_GNUC_CONST;
gpointer schema_ref (gpointer instance);
void schema_unref (gpointer instance);
GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema (GValue* value, gpointer v_object);
void value_take_schema (GValue* value, gpointer v_object);
gpointer value_get_schema (const GValue* value);
GType schema_get_type (void) G_GNUC_CONST;
gpointer schema_value_range_ref (gpointer instance);
void schema_value_range_unref (gpointer instance);
GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_value_range (GValue* value, gpointer v_object);
void value_take_schema_value_range (GValue* value, gpointer v_object);
gpointer value_get_schema_value_range (const GValue* value);
GType schema_value_range_get_type (void) G_GNUC_CONST;
gpointer schema_choice_ref (gpointer instance);
void schema_choice_unref (gpointer instance);
GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_choice (GValue* value, gpointer v_object);
void value_take_schema_choice (GValue* value, gpointer v_object);
gpointer value_get_schema_choice (const GValue* value);
GType schema_choice_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_KEY_DUMMY_PROPERTY
};
static void _schema_choice_unref0_ (gpointer var);
static void _g_list_free__schema_choice_unref0_ (GList* self);
SchemaKey* schema_key_new_from_xml (xmlNode* node, Schema* schema, const gchar* gettext_domain);
SchemaKey* schema_key_construct_from_xml (GType object_type, xmlNode* node, Schema* schema, const gchar* gettext_domain);
SchemaValueRange* schema_value_range_new_from_xml (const gchar* type, xmlNode* node);
SchemaValueRange* schema_value_range_construct_from_xml (GType object_type, const gchar* type, xmlNode* node);
SchemaChoice* schema_choice_new (const gchar* name, GVariant* value);
SchemaChoice* schema_choice_construct (GType object_type, const gchar* name, GVariant* value);
SchemaKey* schema_key_new (void);
SchemaKey* schema_key_construct (GType object_type);
static void schema_key_finalize (SchemaKey* obj);
GType schema_value_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_VALUE_DUMMY_PROPERTY
};
SchemaValue* schema_value_new (guint index, const gchar* nick, gint value);
SchemaValue* schema_value_construct (GType object_type, guint index, const gchar* nick, gint value);
static void schema_value_finalize (GObject* obj);
enum  {
	SCHEMA_CHOICE_DUMMY_PROPERTY
};
static void schema_choice_finalize (SchemaChoice* obj);
enum  {
	SCHEMA_VALUE_RANGE_DUMMY_PROPERTY
};
SchemaValueRange* schema_value_range_new (void);
SchemaValueRange* schema_value_range_construct (GType object_type);
static void schema_value_range_finalize (SchemaValueRange* obj);
gpointer schema_enum_ref (gpointer instance);
void schema_enum_unref (gpointer instance);
GParamSpec* param_spec_schema_enum (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_enum (GValue* value, gpointer v_object);
void value_take_schema_enum (GValue* value, gpointer v_object);
gpointer value_get_schema_enum (const GValue* value);
GType schema_enum_get_type (void) G_GNUC_CONST;
gpointer schema_list_ref (gpointer instance);
void schema_list_unref (gpointer instance);
GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_list (GValue* value, gpointer v_object);
void value_take_schema_list (GValue* value, gpointer v_object);
gpointer value_get_schema_list (const GValue* value);
GType schema_list_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_ENUM_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
SchemaEnum* schema_enum_new_from_xml (SchemaList* list, xmlNode* node);
SchemaEnum* schema_enum_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node);
SchemaEnum* schema_enum_new (void);
SchemaEnum* schema_enum_construct (GType object_type);
static void schema_enum_finalize (SchemaEnum* obj);
gpointer schema_flags_ref (gpointer instance);
void schema_flags_unref (gpointer instance);
GParamSpec* param_spec_schema_flags (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_flags (GValue* value, gpointer v_object);
void value_take_schema_flags (GValue* value, gpointer v_object);
gpointer value_get_schema_flags (const GValue* value);
GType schema_flags_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_FLAGS_DUMMY_PROPERTY
};
SchemaFlags* schema_flags_new_from_xml (SchemaList* list, xmlNode* node);
SchemaFlags* schema_flags_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node);
SchemaFlags* schema_flags_new (void);
SchemaFlags* schema_flags_construct (GType object_type);
static void schema_flags_finalize (SchemaFlags* obj);
enum  {
	SCHEMA_DUMMY_PROPERTY
};
static void _g_free0_ (gpointer var);
static void _schema_key_unref0_ (gpointer var);
Schema* schema_new_from_xml (SchemaList* list, xmlNode* node, const gchar* gettext_domain);
Schema* schema_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node, const gchar* gettext_domain);
Schema* schema_new (void);
Schema* schema_construct (GType object_type);
static void schema_finalize (Schema* obj);
enum  {
	SCHEMA_LIST_DUMMY_PROPERTY
};
static void _schema_unref0_ (gpointer var);
static void _g_list_free__schema_unref0_ (GList* self);
static void _schema_enum_unref0_ (gpointer var);
static void _schema_flags_unref0_ (gpointer var);
void schema_list_parse_file (SchemaList* self, const gchar* path);
void schema_list_load_directory (SchemaList* self, const gchar* dir, GError** error);
SchemaList* schema_list_new (void);
SchemaList* schema_list_construct (GType object_type);
static void schema_list_finalize (SchemaList* obj);


static void _schema_choice_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_choice_unref (var), NULL));
}


static void _g_list_free__schema_choice_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _schema_choice_unref0_, NULL);
	g_list_free (self);
}


static gpointer _schema_ref0 (gpointer self) {
	return self ? schema_ref (self) : NULL;
}


SchemaKey* schema_key_construct_from_xml (GType object_type, xmlNode* node, Schema* schema, const gchar* gettext_domain) {
	SchemaKey* self = NULL;
	Schema* _tmp0_;
	Schema* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (schema != NULL, NULL);
	self = (SchemaKey*) g_type_create_instance (object_type);
	_tmp0_ = schema;
	_tmp1_ = _schema_ref0 (_tmp0_);
	_schema_unref0 (self->schema);
	self->schema = _tmp1_;
	_tmp2_ = gettext_domain;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->gettext_domain);
	self->gettext_domain = _tmp3_;
	{
		xmlNode* _tmp4_;
		xmlAttr* _tmp5_;
		xmlAttr* prop;
		_tmp4_ = node;
		_tmp5_ = _tmp4_->properties;
		prop = _tmp5_;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				xmlAttr* _tmp10_;
				xmlAttr* _tmp11_;
				const gchar* _tmp12_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					xmlAttr* _tmp8_;
					xmlAttr* _tmp9_;
					_tmp8_ = prop;
					_tmp9_ = _tmp8_->next;
					prop = _tmp9_;
				}
				_tmp6_ = FALSE;
				_tmp10_ = prop;
				if (!(_tmp10_ != NULL)) {
					break;
				}
				_tmp11_ = prop;
				_tmp12_ = _tmp11_->name;
				if (g_strcmp0 (_tmp12_, "name") == 0) {
					xmlAttr* _tmp13_;
					xmlNode* _tmp14_;
					const gchar* _tmp15_;
					gchar* _tmp16_;
					_tmp13_ = prop;
					_tmp14_ = _tmp13_->children;
					_tmp15_ = _tmp14_->content;
					_tmp16_ = g_strdup (_tmp15_);
					_g_free0 (self->name);
					self->name = _tmp16_;
				} else {
					xmlAttr* _tmp17_;
					const gchar* _tmp18_;
					_tmp17_ = prop;
					_tmp18_ = _tmp17_->name;
					if (g_strcmp0 (_tmp18_, "type") == 0) {
						xmlAttr* _tmp19_;
						xmlNode* _tmp20_;
						const gchar* _tmp21_;
						gchar* _tmp22_;
						_tmp19_ = prop;
						_tmp20_ = _tmp19_->children;
						_tmp21_ = _tmp20_->content;
						_tmp22_ = g_strdup (_tmp21_);
						_g_free0 (self->type);
						self->type = _tmp22_;
					} else {
						xmlAttr* _tmp23_;
						const gchar* _tmp24_;
						_tmp23_ = prop;
						_tmp24_ = _tmp23_->name;
						if (g_strcmp0 (_tmp24_, "enum") == 0) {
							gchar* _tmp25_;
							xmlAttr* _tmp26_;
							xmlNode* _tmp27_;
							const gchar* _tmp28_;
							gchar* _tmp29_;
							_tmp25_ = g_strdup ("s");
							_g_free0 (self->type);
							self->type = _tmp25_;
							_tmp26_ = prop;
							_tmp27_ = _tmp26_->children;
							_tmp28_ = _tmp27_->content;
							_tmp29_ = g_strdup (_tmp28_);
							_g_free0 (self->enum_name);
							self->enum_name = _tmp29_;
						} else {
							xmlAttr* _tmp30_;
							const gchar* _tmp31_;
							_tmp30_ = prop;
							_tmp31_ = _tmp30_->name;
							if (g_strcmp0 (_tmp31_, "flags") == 0) {
								gchar* _tmp32_;
								_tmp32_ = g_strdup ("as");
								_g_free0 (self->type);
								self->type = _tmp32_;
							} else {
								xmlAttr* _tmp33_;
								const gchar* _tmp34_;
								_tmp33_ = prop;
								_tmp34_ = _tmp33_->name;
								g_warning ("dconf-schema.vala:35: Unknown property on <key>, %s", _tmp34_);
							}
						}
					}
				}
			}
		}
	}
	{
		xmlNode* _tmp35_;
		xmlNode* _tmp36_;
		xmlNode* child;
		_tmp35_ = node;
		_tmp36_ = _tmp35_->children;
		child = _tmp36_;
		{
			gboolean _tmp37_;
			_tmp37_ = TRUE;
			while (TRUE) {
				gboolean _tmp38_;
				xmlNode* _tmp41_;
				xmlNode* _tmp42_;
				const gchar* _tmp43_;
				_tmp38_ = _tmp37_;
				if (!_tmp38_) {
					xmlNode* _tmp39_;
					xmlNode* _tmp40_;
					_tmp39_ = child;
					_tmp40_ = _tmp39_->next;
					child = _tmp40_;
				}
				_tmp37_ = FALSE;
				_tmp41_ = child;
				if (!(_tmp41_ != NULL)) {
					break;
				}
				_tmp42_ = child;
				_tmp43_ = _tmp42_->name;
				if (g_strcmp0 (_tmp43_, "default") == 0) {
					{
						const gchar* _tmp44_;
						GVariantType* _tmp45_;
						GVariantType* _tmp46_;
						xmlNode* _tmp47_;
						xmlNode* _tmp48_;
						const gchar* _tmp49_;
						GVariant* _tmp50_ = NULL;
						GVariant* _tmp51_;
						GVariant* _tmp52_;
						_tmp44_ = self->type;
						_tmp45_ = g_variant_type_new (_tmp44_);
						_tmp46_ = _tmp45_;
						_tmp47_ = child;
						_tmp48_ = _tmp47_->children;
						_tmp49_ = _tmp48_->content;
						_tmp50_ = g_variant_parse (_tmp46_, _tmp49_, NULL, NULL, &_inner_error_);
						_tmp51_ = _tmp50_;
						_g_variant_type_free0 (_tmp46_);
						_tmp52_ = _tmp51_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
								goto __catch5_g_variant_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
						_g_variant_unref0 (self->default_value);
						self->default_value = _tmp52_;
					}
					goto __finally5;
					__catch5_g_variant_parse_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
					}
					__finally5:
					if (_inner_error_ != NULL) {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				} else {
					xmlNode* _tmp53_;
					const gchar* _tmp54_;
					_tmp53_ = child;
					_tmp54_ = _tmp53_->name;
					if (g_strcmp0 (_tmp54_, "summary") == 0) {
						const gchar* _tmp55_ = NULL;
						xmlNode* _tmp56_;
						xmlNode* _tmp57_;
						const gchar* _tmp61_;
						gchar* _tmp62_;
						_tmp56_ = child;
						_tmp57_ = _tmp56_->children;
						if (_tmp57_ == NULL) {
							_tmp55_ = "";
						} else {
							xmlNode* _tmp58_;
							xmlNode* _tmp59_;
							const gchar* _tmp60_;
							_tmp58_ = child;
							_tmp59_ = _tmp58_->children;
							_tmp60_ = _tmp59_->content;
							_tmp55_ = _tmp60_;
						}
						_tmp61_ = _tmp55_;
						_tmp62_ = g_strdup (_tmp61_);
						_g_free0 (self->summary);
						self->summary = _tmp62_;
					} else {
						xmlNode* _tmp63_;
						const gchar* _tmp64_;
						_tmp63_ = child;
						_tmp64_ = _tmp63_->name;
						if (g_strcmp0 (_tmp64_, "description") == 0) {
							const gchar* _tmp65_ = NULL;
							xmlNode* _tmp66_;
							xmlNode* _tmp67_;
							const gchar* _tmp71_;
							gchar* _tmp72_;
							_tmp66_ = child;
							_tmp67_ = _tmp66_->children;
							if (_tmp67_ == NULL) {
								_tmp65_ = "";
							} else {
								xmlNode* _tmp68_;
								xmlNode* _tmp69_;
								const gchar* _tmp70_;
								_tmp68_ = child;
								_tmp69_ = _tmp68_->children;
								_tmp70_ = _tmp69_->content;
								_tmp65_ = _tmp70_;
							}
							_tmp71_ = _tmp65_;
							_tmp72_ = g_strdup (_tmp71_);
							_g_free0 (self->description);
							self->description = _tmp72_;
						} else {
							xmlNode* _tmp73_;
							const gchar* _tmp74_;
							_tmp73_ = child;
							_tmp74_ = _tmp73_->name;
							if (g_strcmp0 (_tmp74_, "range") == 0) {
								const gchar* _tmp75_;
								xmlNode* _tmp76_;
								SchemaValueRange* _tmp77_;
								_tmp75_ = self->type;
								_tmp76_ = child;
								_tmp77_ = schema_value_range_new_from_xml (_tmp75_, _tmp76_);
								_schema_value_range_unref0 (self->range);
								self->range = _tmp77_;
							} else {
								xmlNode* _tmp78_;
								const gchar* _tmp79_;
								_tmp78_ = child;
								_tmp79_ = _tmp78_->name;
								if (g_strcmp0 (_tmp79_, "choices") == 0) {
									{
										xmlNode* _tmp80_;
										xmlNode* _tmp81_;
										xmlNode* n;
										_tmp80_ = child;
										_tmp81_ = _tmp80_->children;
										n = _tmp81_;
										{
											gboolean _tmp82_;
											_tmp82_ = TRUE;
											while (TRUE) {
												gboolean _tmp83_;
												xmlNode* _tmp86_;
												xmlNode* _tmp87_;
												xmlElementType _tmp88_;
												xmlNode* _tmp89_;
												const gchar* _tmp90_;
												gchar* value;
												const gchar* _tmp108_;
												const gchar* _tmp109_;
												GVariant* _tmp110_;
												GVariant* v;
												const gchar* _tmp111_;
												GVariant* _tmp112_;
												SchemaChoice* _tmp113_;
												_tmp83_ = _tmp82_;
												if (!_tmp83_) {
													xmlNode* _tmp84_;
													xmlNode* _tmp85_;
													_tmp84_ = n;
													_tmp85_ = _tmp84_->next;
													n = _tmp85_;
												}
												_tmp82_ = FALSE;
												_tmp86_ = n;
												if (!(_tmp86_ != NULL)) {
													break;
												}
												_tmp87_ = n;
												_tmp88_ = _tmp87_->type;
												if (_tmp88_ != XML_ELEMENT_NODE) {
													continue;
												}
												_tmp89_ = n;
												_tmp90_ = _tmp89_->name;
												if (g_strcmp0 (_tmp90_, "choice") != 0) {
													xmlNode* _tmp91_;
													const gchar* _tmp92_;
													_tmp91_ = n;
													_tmp92_ = _tmp91_->name;
													g_warning ("dconf-schema.vala:68: Unknown child tag in <choices>, <%s>", _tmp92_);
													continue;
												}
												value = NULL;
												{
													xmlNode* _tmp93_;
													xmlAttr* _tmp94_;
													xmlAttr* prop;
													_tmp93_ = n;
													_tmp94_ = _tmp93_->properties;
													prop = _tmp94_;
													{
														gboolean _tmp95_;
														_tmp95_ = TRUE;
														while (TRUE) {
															gboolean _tmp96_;
															xmlAttr* _tmp99_;
															xmlAttr* _tmp100_;
															const gchar* _tmp101_;
															_tmp96_ = _tmp95_;
															if (!_tmp96_) {
																xmlAttr* _tmp97_;
																xmlAttr* _tmp98_;
																_tmp97_ = prop;
																_tmp98_ = _tmp97_->next;
																prop = _tmp98_;
															}
															_tmp95_ = FALSE;
															_tmp99_ = prop;
															if (!(_tmp99_ != NULL)) {
																break;
															}
															_tmp100_ = prop;
															_tmp101_ = _tmp100_->name;
															if (g_strcmp0 (_tmp101_, "value") == 0) {
																xmlAttr* _tmp102_;
																xmlNode* _tmp103_;
																const gchar* _tmp104_;
																gchar* _tmp105_;
																_tmp102_ = prop;
																_tmp103_ = _tmp102_->children;
																_tmp104_ = _tmp103_->content;
																_tmp105_ = g_strdup (_tmp104_);
																_g_free0 (value);
																value = _tmp105_;
															} else {
																xmlAttr* _tmp106_;
																const gchar* _tmp107_;
																_tmp106_ = prop;
																_tmp107_ = _tmp106_->name;
																g_warning ("dconf-schema.vala:78: Unknown property on <choice>, %s", _tmp107_);
															}
														}
													}
												}
												_tmp108_ = value;
												if (_tmp108_ == NULL) {
													g_warning ("dconf-schema.vala:83: Ignoring <choice> with no value");
													_g_free0 (value);
													continue;
												}
												_tmp109_ = value;
												_tmp110_ = g_variant_new_string (_tmp109_);
												g_variant_ref_sink (_tmp110_);
												v = _tmp110_;
												_tmp111_ = value;
												_tmp112_ = v;
												_tmp113_ = schema_choice_new (_tmp111_, _tmp112_);
												self->choices = g_list_append (self->choices, _tmp113_);
												_g_variant_unref0 (v);
												_g_free0 (value);
											}
										}
									}
								} else {
									xmlNode* _tmp114_;
									const gchar* _tmp115_;
									_tmp114_ = child;
									_tmp115_ = _tmp114_->name;
									if (g_strcmp0 (_tmp115_, "aliases") == 0) {
										{
											xmlNode* _tmp116_;
											xmlNode* _tmp117_;
											xmlNode* n;
											_tmp116_ = child;
											_tmp117_ = _tmp116_->children;
											n = _tmp117_;
											{
												gboolean _tmp118_;
												_tmp118_ = TRUE;
												while (TRUE) {
													gboolean _tmp119_;
													xmlNode* _tmp122_;
													xmlNode* _tmp123_;
													xmlElementType _tmp124_;
													xmlNode* _tmp125_;
													const gchar* _tmp126_;
													gchar* value;
													gchar* target;
													const gchar* _tmp150_;
													const gchar* _tmp151_;
													const gchar* _tmp152_;
													GVariant* _tmp153_;
													GVariant* v;
													const gchar* _tmp154_;
													GVariant* _tmp155_;
													SchemaChoice* _tmp156_;
													_tmp119_ = _tmp118_;
													if (!_tmp119_) {
														xmlNode* _tmp120_;
														xmlNode* _tmp121_;
														_tmp120_ = n;
														_tmp121_ = _tmp120_->next;
														n = _tmp121_;
													}
													_tmp118_ = FALSE;
													_tmp122_ = n;
													if (!(_tmp122_ != NULL)) {
														break;
													}
													_tmp123_ = n;
													_tmp124_ = _tmp123_->type;
													if (_tmp124_ != XML_ELEMENT_NODE) {
														continue;
													}
													_tmp125_ = n;
													_tmp126_ = _tmp125_->name;
													if (g_strcmp0 (_tmp126_, "alias") != 0) {
														xmlNode* _tmp127_;
														const gchar* _tmp128_;
														_tmp127_ = n;
														_tmp128_ = _tmp127_->name;
														g_warning ("dconf-schema.vala:99: Unknown child tag in <aliases>, <%s>", _tmp128_);
														continue;
													}
													value = NULL;
													target = NULL;
													{
														xmlNode* _tmp129_;
														xmlAttr* _tmp130_;
														xmlAttr* prop;
														_tmp129_ = n;
														_tmp130_ = _tmp129_->properties;
														prop = _tmp130_;
														{
															gboolean _tmp131_;
															_tmp131_ = TRUE;
															while (TRUE) {
																gboolean _tmp132_;
																xmlAttr* _tmp135_;
																xmlAttr* _tmp136_;
																const gchar* _tmp137_;
																_tmp132_ = _tmp131_;
																if (!_tmp132_) {
																	xmlAttr* _tmp133_;
																	xmlAttr* _tmp134_;
																	_tmp133_ = prop;
																	_tmp134_ = _tmp133_->next;
																	prop = _tmp134_;
																}
																_tmp131_ = FALSE;
																_tmp135_ = prop;
																if (!(_tmp135_ != NULL)) {
																	break;
																}
																_tmp136_ = prop;
																_tmp137_ = _tmp136_->name;
																if (g_strcmp0 (_tmp137_, "value") == 0) {
																	xmlAttr* _tmp138_;
																	xmlNode* _tmp139_;
																	const gchar* _tmp140_;
																	gchar* _tmp141_;
																	_tmp138_ = prop;
																	_tmp139_ = _tmp138_->children;
																	_tmp140_ = _tmp139_->content;
																	_tmp141_ = g_strdup (_tmp140_);
																	_g_free0 (value);
																	value = _tmp141_;
																} else {
																	xmlAttr* _tmp142_;
																	const gchar* _tmp143_;
																	_tmp142_ = prop;
																	_tmp143_ = _tmp142_->name;
																	if (g_strcmp0 (_tmp143_, "target") == 0) {
																		xmlAttr* _tmp144_;
																		xmlNode* _tmp145_;
																		const gchar* _tmp146_;
																		gchar* _tmp147_;
																		_tmp144_ = prop;
																		_tmp145_ = _tmp144_->children;
																		_tmp146_ = _tmp145_->content;
																		_tmp147_ = g_strdup (_tmp146_);
																		_g_free0 (target);
																		target = _tmp147_;
																	} else {
																		xmlAttr* _tmp148_;
																		const gchar* _tmp149_;
																		_tmp148_ = prop;
																		_tmp149_ = _tmp148_->name;
																		g_warning ("dconf-schema.vala:111: Unknown property on <alias>, %s", _tmp149_);
																	}
																}
															}
														}
													}
													_tmp150_ = value;
													if (_tmp150_ == NULL) {
														g_warning ("dconf-schema.vala:116: Ignoring <alias> with no value");
														_g_free0 (target);
														_g_free0 (value);
														continue;
													}
													_tmp151_ = target;
													if (_tmp151_ == NULL) {
														g_warning ("dconf-schema.vala:121: Ignoring <alias> with no target");
														_g_free0 (target);
														_g_free0 (value);
														continue;
													}
													_tmp152_ = target;
													_tmp153_ = g_variant_new_string (_tmp152_);
													g_variant_ref_sink (_tmp153_);
													v = _tmp153_;
													_tmp154_ = value;
													_tmp155_ = v;
													_tmp156_ = schema_choice_new (_tmp154_, _tmp155_);
													self->choices = g_list_append (self->choices, _tmp156_);
													_g_variant_unref0 (v);
													_g_free0 (target);
													_g_free0 (value);
												}
											}
										}
									} else {
										gboolean _tmp157_ = FALSE;
										xmlNode* _tmp158_;
										xmlElementType _tmp159_;
										gboolean _tmp162_;
										_tmp158_ = child;
										_tmp159_ = _tmp158_->type;
										if (_tmp159_ != XML_TEXT_NODE) {
											xmlNode* _tmp160_;
											xmlElementType _tmp161_;
											_tmp160_ = child;
											_tmp161_ = _tmp160_->type;
											_tmp157_ = _tmp161_ != XML_COMMENT_NODE;
										} else {
											_tmp157_ = FALSE;
										}
										_tmp162_ = _tmp157_;
										if (_tmp162_) {
											xmlNode* _tmp163_;
											const gchar* _tmp164_;
											_tmp163_ = child;
											_tmp164_ = _tmp163_->name;
											g_warning ("dconf-schema.vala:130: Unknown child tag in <key>, <%s>", _tmp164_);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return self;
}


SchemaKey* schema_key_new_from_xml (xmlNode* node, Schema* schema, const gchar* gettext_domain) {
	return schema_key_construct_from_xml (TYPE_SCHEMA_KEY, node, schema, gettext_domain);
}


SchemaKey* schema_key_construct (GType object_type) {
	SchemaKey* self = NULL;
	self = (SchemaKey*) g_type_create_instance (object_type);
	return self;
}


SchemaKey* schema_key_new (void) {
	return schema_key_construct (TYPE_SCHEMA_KEY);
}


static void value_schema_key_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_key_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_key_unref (value->data[0].v_pointer);
	}
}


static void value_schema_key_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_key_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_key_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_key_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaKey* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_key_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_key_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaKey** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_key_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaKey* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_KEY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_key (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_key (GValue* value, gpointer v_object) {
	SchemaKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_key_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_key_unref (old);
	}
}


void value_take_schema_key (GValue* value, gpointer v_object) {
	SchemaKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_key_unref (old);
	}
}


static void schema_key_class_init (SchemaKeyClass * klass) {
	schema_key_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_KEY_CLASS (klass)->finalize = schema_key_finalize;
}


static void schema_key_instance_init (SchemaKey * self) {
	self->ref_count = 1;
}


static void schema_key_finalize (SchemaKey* obj) {
	SchemaKey * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_KEY, SchemaKey);
	_schema_unref0 (self->schema);
	_g_free0 (self->name);
	_g_free0 (self->type);
	_g_variant_unref0 (self->default_value);
	_schema_value_range_unref0 (self->range);
	_schema_value_range_unref0 (self->type_range);
	__g_list_free__schema_choice_unref0_0 (self->choices);
	_g_free0 (self->enum_name);
	_g_free0 (self->summary);
	_g_free0 (self->description);
	_g_free0 (self->gettext_domain);
}


GType schema_key_get_type (void) {
	static volatile gsize schema_key_type_id__volatile = 0;
	if (g_once_init_enter (&schema_key_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_key_init, value_schema_key_free_value, value_schema_key_copy_value, value_schema_key_peek_pointer, "p", value_schema_key_collect_value, "p", value_schema_key_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaKeyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_key_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaKey), 0, (GInstanceInitFunc) schema_key_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_key_type_id;
		schema_key_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaKey", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_key_type_id__volatile, schema_key_type_id);
	}
	return schema_key_type_id__volatile;
}


gpointer schema_key_ref (gpointer instance) {
	SchemaKey* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_key_unref (gpointer instance) {
	SchemaKey* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_KEY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaValue* schema_value_construct (GType object_type, guint index, const gchar* nick, gint value) {
	SchemaValue * self = NULL;
	guint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gint _tmp3_;
	g_return_val_if_fail (nick != NULL, NULL);
	self = (SchemaValue*) g_object_new (object_type, NULL);
	_tmp0_ = index;
	self->index = _tmp0_;
	_tmp1_ = nick;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->nick);
	self->nick = _tmp2_;
	_tmp3_ = value;
	self->value = _tmp3_;
	return self;
}


SchemaValue* schema_value_new (guint index, const gchar* nick, gint value) {
	return schema_value_construct (TYPE_SCHEMA_VALUE, index, nick, value);
}


static void schema_value_class_init (SchemaValueClass * klass) {
	schema_value_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = schema_value_finalize;
}


static void schema_value_instance_init (SchemaValue * self) {
}


static void schema_value_finalize (GObject* obj) {
	SchemaValue * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_VALUE, SchemaValue);
	_g_free0 (self->nick);
	G_OBJECT_CLASS (schema_value_parent_class)->finalize (obj);
}


GType schema_value_get_type (void) {
	static volatile gsize schema_value_type_id__volatile = 0;
	if (g_once_init_enter (&schema_value_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SchemaValueClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_value_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaValue), 0, (GInstanceInitFunc) schema_value_instance_init, NULL };
		GType schema_value_type_id;
		schema_value_type_id = g_type_register_static (G_TYPE_OBJECT, "SchemaValue", &g_define_type_info, 0);
		g_once_init_leave (&schema_value_type_id__volatile, schema_value_type_id);
	}
	return schema_value_type_id__volatile;
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


SchemaChoice* schema_choice_construct (GType object_type, const gchar* name, GVariant* value) {
	SchemaChoice* self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (value != NULL, NULL);
	self = (SchemaChoice*) g_type_create_instance (object_type);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = _g_variant_ref0 (_tmp2_);
	_g_variant_unref0 (self->value);
	self->value = _tmp3_;
	return self;
}


SchemaChoice* schema_choice_new (const gchar* name, GVariant* value) {
	return schema_choice_construct (TYPE_SCHEMA_CHOICE, name, value);
}


static void value_schema_choice_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_choice_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_choice_unref (value->data[0].v_pointer);
	}
}


static void value_schema_choice_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_choice_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_choice_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_choice_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaChoice* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_choice_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_choice_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaChoice** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_choice_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaChoice* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_CHOICE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_choice (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_choice (GValue* value, gpointer v_object) {
	SchemaChoice* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_CHOICE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_choice_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_choice_unref (old);
	}
}


void value_take_schema_choice (GValue* value, gpointer v_object) {
	SchemaChoice* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_CHOICE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_choice_unref (old);
	}
}


static void schema_choice_class_init (SchemaChoiceClass * klass) {
	schema_choice_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_CHOICE_CLASS (klass)->finalize = schema_choice_finalize;
}


static void schema_choice_instance_init (SchemaChoice * self) {
	self->ref_count = 1;
}


static void schema_choice_finalize (SchemaChoice* obj) {
	SchemaChoice * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_CHOICE, SchemaChoice);
	_g_free0 (self->name);
	_g_variant_unref0 (self->value);
}


GType schema_choice_get_type (void) {
	static volatile gsize schema_choice_type_id__volatile = 0;
	if (g_once_init_enter (&schema_choice_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_choice_init, value_schema_choice_free_value, value_schema_choice_copy_value, value_schema_choice_peek_pointer, "p", value_schema_choice_collect_value, "p", value_schema_choice_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaChoiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_choice_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaChoice), 0, (GInstanceInitFunc) schema_choice_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_choice_type_id;
		schema_choice_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaChoice", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_choice_type_id__volatile, schema_choice_type_id);
	}
	return schema_choice_type_id__volatile;
}


gpointer schema_choice_ref (gpointer instance) {
	SchemaChoice* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_choice_unref (gpointer instance) {
	SchemaChoice* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_CHOICE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaValueRange* schema_value_range_construct_from_xml (GType object_type, const gchar* type, xmlNode* node) {
	SchemaValueRange* self = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (type != NULL, NULL);
	self = (SchemaValueRange*) g_type_create_instance (object_type);
	{
		xmlNode* _tmp0_;
		xmlAttr* _tmp1_;
		xmlAttr* prop;
		_tmp0_ = node;
		_tmp1_ = _tmp0_->properties;
		prop = _tmp1_;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				xmlAttr* _tmp6_;
				xmlAttr* _tmp7_;
				const gchar* _tmp8_;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					xmlAttr* _tmp4_;
					xmlAttr* _tmp5_;
					_tmp4_ = prop;
					_tmp5_ = _tmp4_->next;
					prop = _tmp5_;
				}
				_tmp2_ = FALSE;
				_tmp6_ = prop;
				if (!(_tmp6_ != NULL)) {
					break;
				}
				_tmp7_ = prop;
				_tmp8_ = _tmp7_->name;
				if (g_strcmp0 (_tmp8_, "min") == 0) {
					{
						const gchar* _tmp9_;
						GVariantType* _tmp10_;
						GVariantType* _tmp11_;
						xmlAttr* _tmp12_;
						xmlNode* _tmp13_;
						const gchar* _tmp14_;
						GVariant* _tmp15_ = NULL;
						GVariant* _tmp16_;
						GVariant* _tmp17_;
						_tmp9_ = type;
						_tmp10_ = g_variant_type_new (_tmp9_);
						_tmp11_ = _tmp10_;
						_tmp12_ = prop;
						_tmp13_ = _tmp12_->children;
						_tmp14_ = _tmp13_->content;
						_tmp15_ = g_variant_parse (_tmp11_, _tmp14_, NULL, NULL, &_inner_error_);
						_tmp16_ = _tmp15_;
						_g_variant_type_free0 (_tmp11_);
						_tmp17_ = _tmp16_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
								goto __catch6_g_variant_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
						_g_variant_unref0 (self->min);
						self->min = _tmp17_;
					}
					goto __finally6;
					__catch6_g_variant_parse_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
					}
					__finally6:
					if (_inner_error_ != NULL) {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				} else {
					xmlAttr* _tmp18_;
					const gchar* _tmp19_;
					_tmp18_ = prop;
					_tmp19_ = _tmp18_->name;
					if (g_strcmp0 (_tmp19_, "max") == 0) {
						{
							const gchar* _tmp20_;
							GVariantType* _tmp21_;
							GVariantType* _tmp22_;
							xmlAttr* _tmp23_;
							xmlNode* _tmp24_;
							const gchar* _tmp25_;
							GVariant* _tmp26_ = NULL;
							GVariant* _tmp27_;
							GVariant* _tmp28_;
							_tmp20_ = type;
							_tmp21_ = g_variant_type_new (_tmp20_);
							_tmp22_ = _tmp21_;
							_tmp23_ = prop;
							_tmp24_ = _tmp23_->children;
							_tmp25_ = _tmp24_->content;
							_tmp26_ = g_variant_parse (_tmp22_, _tmp25_, NULL, NULL, &_inner_error_);
							_tmp27_ = _tmp26_;
							_g_variant_type_free0 (_tmp22_);
							_tmp28_ = _tmp27_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
									goto __catch7_g_variant_parse_error;
								}
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
							_g_variant_unref0 (self->max);
							self->max = _tmp28_;
						}
						goto __finally7;
						__catch7_g_variant_parse_error:
						{
							GError* e = NULL;
							e = _inner_error_;
							_inner_error_ = NULL;
							_g_error_free0 (e);
						}
						__finally7:
						if (_inner_error_ != NULL) {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					} else {
						xmlAttr* _tmp29_;
						const gchar* _tmp30_;
						_tmp29_ = prop;
						_tmp30_ = _tmp29_->name;
						g_warning ("dconf-schema.vala:196: Unknown property in <range>, %s", _tmp30_);
					}
				}
			}
		}
	}
	return self;
}


SchemaValueRange* schema_value_range_new_from_xml (const gchar* type, xmlNode* node) {
	return schema_value_range_construct_from_xml (TYPE_SCHEMA_VALUE_RANGE, type, node);
}


SchemaValueRange* schema_value_range_construct (GType object_type) {
	SchemaValueRange* self = NULL;
	self = (SchemaValueRange*) g_type_create_instance (object_type);
	return self;
}


SchemaValueRange* schema_value_range_new (void) {
	return schema_value_range_construct (TYPE_SCHEMA_VALUE_RANGE);
}


static void value_schema_value_range_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_value_range_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_value_range_unref (value->data[0].v_pointer);
	}
}


static void value_schema_value_range_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_value_range_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_value_range_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_value_range_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaValueRange* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_value_range_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_value_range_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaValueRange** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_value_range_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaValueRange* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_VALUE_RANGE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_value_range (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_value_range (GValue* value, gpointer v_object) {
	SchemaValueRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_VALUE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_value_range_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_value_range_unref (old);
	}
}


void value_take_schema_value_range (GValue* value, gpointer v_object) {
	SchemaValueRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_VALUE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_value_range_unref (old);
	}
}


static void schema_value_range_class_init (SchemaValueRangeClass * klass) {
	schema_value_range_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_VALUE_RANGE_CLASS (klass)->finalize = schema_value_range_finalize;
}


static void schema_value_range_instance_init (SchemaValueRange * self) {
	self->ref_count = 1;
}


static void schema_value_range_finalize (SchemaValueRange* obj) {
	SchemaValueRange * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange);
	_g_variant_unref0 (self->min);
	_g_variant_unref0 (self->max);
}


GType schema_value_range_get_type (void) {
	static volatile gsize schema_value_range_type_id__volatile = 0;
	if (g_once_init_enter (&schema_value_range_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_value_range_init, value_schema_value_range_free_value, value_schema_value_range_copy_value, value_schema_value_range_peek_pointer, "p", value_schema_value_range_collect_value, "p", value_schema_value_range_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaValueRangeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_value_range_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaValueRange), 0, (GInstanceInitFunc) schema_value_range_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_value_range_type_id;
		schema_value_range_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaValueRange", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_value_range_type_id__volatile, schema_value_range_type_id);
	}
	return schema_value_range_type_id__volatile;
}


gpointer schema_value_range_ref (gpointer instance) {
	SchemaValueRange* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_value_range_unref (gpointer instance) {
	SchemaValueRange* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_VALUE_RANGE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gpointer _schema_list_ref0 (gpointer self) {
	return self ? schema_list_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


SchemaEnum* schema_enum_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node) {
	SchemaEnum* self = NULL;
	SchemaList* _tmp0_;
	SchemaList* _tmp1_;
	g_return_val_if_fail (list != NULL, NULL);
	self = (SchemaEnum*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlNode* _tmp2_;
		xmlAttr* _tmp3_;
		xmlAttr* prop;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				xmlAttr* _tmp8_;
				xmlAttr* _tmp9_;
				const gchar* _tmp10_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					xmlAttr* _tmp6_;
					xmlAttr* _tmp7_;
					_tmp6_ = prop;
					_tmp7_ = _tmp6_->next;
					prop = _tmp7_;
				}
				_tmp4_ = FALSE;
				_tmp8_ = prop;
				if (!(_tmp8_ != NULL)) {
					break;
				}
				_tmp9_ = prop;
				_tmp10_ = _tmp9_->name;
				if (g_strcmp0 (_tmp10_, "id") == 0) {
					xmlAttr* _tmp11_;
					xmlNode* _tmp12_;
					const gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp11_ = prop;
					_tmp12_ = _tmp11_->children;
					_tmp13_ = _tmp12_->content;
					_tmp14_ = g_strdup (_tmp13_);
					_g_free0 (self->id);
					self->id = _tmp14_;
				} else {
					xmlAttr* _tmp15_;
					const gchar* _tmp16_;
					_tmp15_ = prop;
					_tmp16_ = _tmp15_->name;
					g_warning ("dconf-schema.vala:219: Unknown property in <enum>, %s", _tmp16_);
				}
			}
		}
	}
	{
		xmlNode* _tmp17_;
		xmlNode* _tmp18_;
		xmlNode* child;
		_tmp17_ = node;
		_tmp18_ = _tmp17_->children;
		child = _tmp18_;
		{
			gboolean _tmp19_;
			_tmp19_ = TRUE;
			while (TRUE) {
				gboolean _tmp20_;
				xmlNode* _tmp23_;
				xmlNode* _tmp24_;
				const gchar* _tmp25_;
				_tmp20_ = _tmp19_;
				if (!_tmp20_) {
					xmlNode* _tmp21_;
					xmlNode* _tmp22_;
					_tmp21_ = child;
					_tmp22_ = _tmp21_->next;
					child = _tmp22_;
				}
				_tmp19_ = FALSE;
				_tmp23_ = child;
				if (!(_tmp23_ != NULL)) {
					break;
				}
				_tmp24_ = child;
				_tmp25_ = _tmp24_->name;
				if (g_strcmp0 (_tmp25_, "value") == 0) {
					gchar* nick;
					gint value;
					GList* _tmp47_;
					guint _tmp48_ = 0U;
					const gchar* _tmp49_;
					gint _tmp50_;
					SchemaValue* _tmp51_;
					SchemaValue* schema_value;
					SchemaValue* _tmp52_;
					SchemaValue* _tmp53_;
					nick = NULL;
					value = -1;
					{
						xmlNode* _tmp26_;
						xmlAttr* _tmp27_;
						xmlAttr* prop;
						_tmp26_ = child;
						_tmp27_ = _tmp26_->properties;
						prop = _tmp27_;
						{
							gboolean _tmp28_;
							_tmp28_ = TRUE;
							while (TRUE) {
								gboolean _tmp29_;
								xmlAttr* _tmp32_;
								xmlAttr* _tmp33_;
								const gchar* _tmp34_;
								_tmp29_ = _tmp28_;
								if (!_tmp29_) {
									xmlAttr* _tmp30_;
									xmlAttr* _tmp31_;
									_tmp30_ = prop;
									_tmp31_ = _tmp30_->next;
									prop = _tmp31_;
								}
								_tmp28_ = FALSE;
								_tmp32_ = prop;
								if (!(_tmp32_ != NULL)) {
									break;
								}
								_tmp33_ = prop;
								_tmp34_ = _tmp33_->name;
								if (g_strcmp0 (_tmp34_, "value") == 0) {
									xmlAttr* _tmp35_;
									xmlNode* _tmp36_;
									const gchar* _tmp37_;
									gint _tmp38_ = 0;
									_tmp35_ = prop;
									_tmp36_ = _tmp35_->children;
									_tmp37_ = _tmp36_->content;
									_tmp38_ = atoi (_tmp37_);
									value = _tmp38_;
								} else {
									xmlAttr* _tmp39_;
									const gchar* _tmp40_;
									_tmp39_ = prop;
									_tmp40_ = _tmp39_->name;
									if (g_strcmp0 (_tmp40_, "nick") == 0) {
										xmlAttr* _tmp41_;
										xmlNode* _tmp42_;
										const gchar* _tmp43_;
										gchar* _tmp44_;
										_tmp41_ = prop;
										_tmp42_ = _tmp41_->children;
										_tmp43_ = _tmp42_->content;
										_tmp44_ = g_strdup (_tmp43_);
										_g_free0 (nick);
										nick = _tmp44_;
									} else {
										xmlAttr* _tmp45_;
										const gchar* _tmp46_;
										_tmp45_ = prop;
										_tmp46_ = _tmp45_->name;
										g_warning ("dconf-schema.vala:239: Unknown property in enum <value>, %s", _tmp46_);
									}
								}
							}
						}
					}
					_tmp47_ = self->values;
					_tmp48_ = g_list_length (_tmp47_);
					_tmp49_ = nick;
					_tmp50_ = value;
					_tmp51_ = schema_value_new (_tmp48_, _tmp49_, _tmp50_);
					schema_value = _tmp51_;
					_tmp52_ = schema_value;
					_tmp53_ = _g_object_ref0 (_tmp52_);
					self->values = g_list_append (self->values, _tmp53_);
					_g_object_unref0 (schema_value);
					_g_free0 (nick);
				} else {
					gboolean _tmp54_ = FALSE;
					xmlNode* _tmp55_;
					xmlElementType _tmp56_;
					gboolean _tmp59_;
					_tmp55_ = child;
					_tmp56_ = _tmp55_->type;
					if (_tmp56_ != XML_TEXT_NODE) {
						xmlNode* _tmp57_;
						xmlElementType _tmp58_;
						_tmp57_ = child;
						_tmp58_ = _tmp57_->type;
						_tmp54_ = _tmp58_ != XML_COMMENT_NODE;
					} else {
						_tmp54_ = FALSE;
					}
					_tmp59_ = _tmp54_;
					if (_tmp59_) {
						xmlNode* _tmp60_;
						const gchar* _tmp61_;
						_tmp60_ = child;
						_tmp61_ = _tmp60_->name;
						g_warning ("dconf-schema.vala:249: Unknown tag in <enum>, <%s>", _tmp61_);
					}
				}
			}
		}
	}
	return self;
}


SchemaEnum* schema_enum_new_from_xml (SchemaList* list, xmlNode* node) {
	return schema_enum_construct_from_xml (TYPE_SCHEMA_ENUM, list, node);
}


SchemaEnum* schema_enum_construct (GType object_type) {
	SchemaEnum* self = NULL;
	self = (SchemaEnum*) g_type_create_instance (object_type);
	return self;
}


SchemaEnum* schema_enum_new (void) {
	return schema_enum_construct (TYPE_SCHEMA_ENUM);
}


static void value_schema_enum_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_enum_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_enum_unref (value->data[0].v_pointer);
	}
}


static void value_schema_enum_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_enum_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_enum_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_enum_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaEnum* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_enum_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_enum_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaEnum** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_enum_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_enum (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaEnum* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_ENUM), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_enum (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_enum (GValue* value, gpointer v_object) {
	SchemaEnum* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_ENUM));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_enum_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_enum_unref (old);
	}
}


void value_take_schema_enum (GValue* value, gpointer v_object) {
	SchemaEnum* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_ENUM));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_enum_unref (old);
	}
}


static void schema_enum_class_init (SchemaEnumClass * klass) {
	schema_enum_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_ENUM_CLASS (klass)->finalize = schema_enum_finalize;
}


static void schema_enum_instance_init (SchemaEnum * self) {
	self->values = NULL;
	self->ref_count = 1;
}


static void schema_enum_finalize (SchemaEnum* obj) {
	SchemaEnum * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_ENUM, SchemaEnum);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	__g_list_free__g_object_unref0_0 (self->values);
}


GType schema_enum_get_type (void) {
	static volatile gsize schema_enum_type_id__volatile = 0;
	if (g_once_init_enter (&schema_enum_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_enum_init, value_schema_enum_free_value, value_schema_enum_copy_value, value_schema_enum_peek_pointer, "p", value_schema_enum_collect_value, "p", value_schema_enum_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaEnumClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_enum_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaEnum), 0, (GInstanceInitFunc) schema_enum_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_enum_type_id;
		schema_enum_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaEnum", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_enum_type_id__volatile, schema_enum_type_id);
	}
	return schema_enum_type_id__volatile;
}


gpointer schema_enum_ref (gpointer instance) {
	SchemaEnum* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_enum_unref (gpointer instance) {
	SchemaEnum* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_ENUM_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaFlags* schema_flags_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node) {
	SchemaFlags* self = NULL;
	SchemaList* _tmp0_;
	SchemaList* _tmp1_;
	g_return_val_if_fail (list != NULL, NULL);
	self = (SchemaFlags*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlNode* _tmp2_;
		xmlAttr* _tmp3_;
		xmlAttr* prop;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				xmlAttr* _tmp8_;
				xmlAttr* _tmp9_;
				const gchar* _tmp10_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					xmlAttr* _tmp6_;
					xmlAttr* _tmp7_;
					_tmp6_ = prop;
					_tmp7_ = _tmp6_->next;
					prop = _tmp7_;
				}
				_tmp4_ = FALSE;
				_tmp8_ = prop;
				if (!(_tmp8_ != NULL)) {
					break;
				}
				_tmp9_ = prop;
				_tmp10_ = _tmp9_->name;
				if (g_strcmp0 (_tmp10_, "id") == 0) {
					xmlAttr* _tmp11_;
					xmlNode* _tmp12_;
					const gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp11_ = prop;
					_tmp12_ = _tmp11_->children;
					_tmp13_ = _tmp12_->content;
					_tmp14_ = g_strdup (_tmp13_);
					_g_free0 (self->id);
					self->id = _tmp14_;
				} else {
					xmlAttr* _tmp15_;
					const gchar* _tmp16_;
					_tmp15_ = prop;
					_tmp16_ = _tmp15_->name;
					g_warning ("dconf-schema.vala:272: Unknown property in <flags>, %s", _tmp16_);
				}
			}
		}
	}
	{
		xmlNode* _tmp17_;
		xmlNode* _tmp18_;
		xmlNode* child;
		_tmp17_ = node;
		_tmp18_ = _tmp17_->children;
		child = _tmp18_;
		{
			gboolean _tmp19_;
			_tmp19_ = TRUE;
			while (TRUE) {
				gboolean _tmp20_;
				xmlNode* _tmp23_;
				xmlNode* _tmp24_;
				const gchar* _tmp25_;
				_tmp20_ = _tmp19_;
				if (!_tmp20_) {
					xmlNode* _tmp21_;
					xmlNode* _tmp22_;
					_tmp21_ = child;
					_tmp22_ = _tmp21_->next;
					child = _tmp22_;
				}
				_tmp19_ = FALSE;
				_tmp23_ = child;
				if (!(_tmp23_ != NULL)) {
					break;
				}
				_tmp24_ = child;
				_tmp25_ = _tmp24_->name;
				if (g_strcmp0 (_tmp25_, "value") == 0) {
					gchar* nick;
					gint value;
					GList* _tmp47_;
					guint _tmp48_ = 0U;
					const gchar* _tmp49_;
					gint _tmp50_;
					SchemaValue* _tmp51_;
					SchemaValue* schema_value;
					SchemaValue* _tmp52_;
					SchemaValue* _tmp53_;
					nick = NULL;
					value = -1;
					{
						xmlNode* _tmp26_;
						xmlAttr* _tmp27_;
						xmlAttr* prop;
						_tmp26_ = child;
						_tmp27_ = _tmp26_->properties;
						prop = _tmp27_;
						{
							gboolean _tmp28_;
							_tmp28_ = TRUE;
							while (TRUE) {
								gboolean _tmp29_;
								xmlAttr* _tmp32_;
								xmlAttr* _tmp33_;
								const gchar* _tmp34_;
								_tmp29_ = _tmp28_;
								if (!_tmp29_) {
									xmlAttr* _tmp30_;
									xmlAttr* _tmp31_;
									_tmp30_ = prop;
									_tmp31_ = _tmp30_->next;
									prop = _tmp31_;
								}
								_tmp28_ = FALSE;
								_tmp32_ = prop;
								if (!(_tmp32_ != NULL)) {
									break;
								}
								_tmp33_ = prop;
								_tmp34_ = _tmp33_->name;
								if (g_strcmp0 (_tmp34_, "value") == 0) {
									xmlAttr* _tmp35_;
									xmlNode* _tmp36_;
									const gchar* _tmp37_;
									gint _tmp38_ = 0;
									_tmp35_ = prop;
									_tmp36_ = _tmp35_->children;
									_tmp37_ = _tmp36_->content;
									_tmp38_ = atoi (_tmp37_);
									value = _tmp38_;
								} else {
									xmlAttr* _tmp39_;
									const gchar* _tmp40_;
									_tmp39_ = prop;
									_tmp40_ = _tmp39_->name;
									if (g_strcmp0 (_tmp40_, "nick") == 0) {
										xmlAttr* _tmp41_;
										xmlNode* _tmp42_;
										const gchar* _tmp43_;
										gchar* _tmp44_;
										_tmp41_ = prop;
										_tmp42_ = _tmp41_->children;
										_tmp43_ = _tmp42_->content;
										_tmp44_ = g_strdup (_tmp43_);
										_g_free0 (nick);
										nick = _tmp44_;
									} else {
										xmlAttr* _tmp45_;
										const gchar* _tmp46_;
										_tmp45_ = prop;
										_tmp46_ = _tmp45_->name;
										g_warning ("dconf-schema.vala:292: Unknown property in flags <value>, %s", _tmp46_);
									}
								}
							}
						}
					}
					_tmp47_ = self->values;
					_tmp48_ = g_list_length (_tmp47_);
					_tmp49_ = nick;
					_tmp50_ = value;
					_tmp51_ = schema_value_new (_tmp48_, _tmp49_, _tmp50_);
					schema_value = _tmp51_;
					_tmp52_ = schema_value;
					_tmp53_ = _g_object_ref0 (_tmp52_);
					self->values = g_list_append (self->values, _tmp53_);
					_g_object_unref0 (schema_value);
					_g_free0 (nick);
				} else {
					gboolean _tmp54_ = FALSE;
					xmlNode* _tmp55_;
					xmlElementType _tmp56_;
					gboolean _tmp59_;
					_tmp55_ = child;
					_tmp56_ = _tmp55_->type;
					if (_tmp56_ != XML_TEXT_NODE) {
						xmlNode* _tmp57_;
						xmlElementType _tmp58_;
						_tmp57_ = child;
						_tmp58_ = _tmp57_->type;
						_tmp54_ = _tmp58_ != XML_COMMENT_NODE;
					} else {
						_tmp54_ = FALSE;
					}
					_tmp59_ = _tmp54_;
					if (_tmp59_) {
						xmlNode* _tmp60_;
						const gchar* _tmp61_;
						_tmp60_ = child;
						_tmp61_ = _tmp60_->name;
						g_warning ("dconf-schema.vala:302: Unknown tag in <flags>, <%s>", _tmp61_);
					}
				}
			}
		}
	}
	return self;
}


SchemaFlags* schema_flags_new_from_xml (SchemaList* list, xmlNode* node) {
	return schema_flags_construct_from_xml (TYPE_SCHEMA_FLAGS, list, node);
}


SchemaFlags* schema_flags_construct (GType object_type) {
	SchemaFlags* self = NULL;
	self = (SchemaFlags*) g_type_create_instance (object_type);
	return self;
}


SchemaFlags* schema_flags_new (void) {
	return schema_flags_construct (TYPE_SCHEMA_FLAGS);
}


static void value_schema_flags_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_flags_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_flags_unref (value->data[0].v_pointer);
	}
}


static void value_schema_flags_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_flags_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_flags_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_flags_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaFlags* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_flags_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_flags_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaFlags** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_flags_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_flags (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaFlags* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_FLAGS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_flags (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_flags (GValue* value, gpointer v_object) {
	SchemaFlags* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_FLAGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_flags_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_flags_unref (old);
	}
}


void value_take_schema_flags (GValue* value, gpointer v_object) {
	SchemaFlags* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_FLAGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_flags_unref (old);
	}
}


static void schema_flags_class_init (SchemaFlagsClass * klass) {
	schema_flags_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_FLAGS_CLASS (klass)->finalize = schema_flags_finalize;
}


static void schema_flags_instance_init (SchemaFlags * self) {
	self->values = NULL;
	self->ref_count = 1;
}


static void schema_flags_finalize (SchemaFlags* obj) {
	SchemaFlags * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_FLAGS, SchemaFlags);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	__g_list_free__g_object_unref0_0 (self->values);
}


GType schema_flags_get_type (void) {
	static volatile gsize schema_flags_type_id__volatile = 0;
	if (g_once_init_enter (&schema_flags_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_flags_init, value_schema_flags_free_value, value_schema_flags_copy_value, value_schema_flags_peek_pointer, "p", value_schema_flags_collect_value, "p", value_schema_flags_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaFlagsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_flags_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaFlags), 0, (GInstanceInitFunc) schema_flags_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_flags_type_id;
		schema_flags_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaFlags", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_flags_type_id__volatile, schema_flags_type_id);
	}
	return schema_flags_type_id__volatile;
}


gpointer schema_flags_ref (gpointer instance) {
	SchemaFlags* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_flags_unref (gpointer instance) {
	SchemaFlags* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_FLAGS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _schema_key_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_key_unref (var), NULL));
}


static gpointer _schema_key_ref0 (gpointer self) {
	return self ? schema_key_ref (self) : NULL;
}


Schema* schema_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node, const gchar* gettext_domain) {
	Schema* self = NULL;
	SchemaList* _tmp0_;
	SchemaList* _tmp1_;
	g_return_val_if_fail (list != NULL, NULL);
	self = (Schema*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlNode* _tmp2_;
		xmlAttr* _tmp3_;
		xmlAttr* prop;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				xmlAttr* _tmp8_;
				xmlAttr* _tmp9_;
				const gchar* _tmp10_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					xmlAttr* _tmp6_;
					xmlAttr* _tmp7_;
					_tmp6_ = prop;
					_tmp7_ = _tmp6_->next;
					prop = _tmp7_;
				}
				_tmp4_ = FALSE;
				_tmp8_ = prop;
				if (!(_tmp8_ != NULL)) {
					break;
				}
				_tmp9_ = prop;
				_tmp10_ = _tmp9_->name;
				if (g_strcmp0 (_tmp10_, "id") == 0) {
					xmlAttr* _tmp11_;
					xmlNode* _tmp12_;
					const gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp11_ = prop;
					_tmp12_ = _tmp11_->children;
					_tmp13_ = _tmp12_->content;
					_tmp14_ = g_strdup (_tmp13_);
					_g_free0 (self->id);
					self->id = _tmp14_;
				} else {
					xmlAttr* _tmp15_;
					const gchar* _tmp16_;
					_tmp15_ = prop;
					_tmp16_ = _tmp15_->name;
					if (g_strcmp0 (_tmp16_, "path") == 0) {
						xmlAttr* _tmp17_;
						xmlNode* _tmp18_;
						const gchar* _tmp19_;
						gchar* _tmp20_;
						_tmp17_ = prop;
						_tmp18_ = _tmp17_->children;
						_tmp19_ = _tmp18_->content;
						_tmp20_ = g_strdup (_tmp19_);
						_g_free0 (self->path);
						self->path = _tmp20_;
					} else {
						xmlAttr* _tmp21_;
						const gchar* _tmp22_;
						_tmp21_ = prop;
						_tmp22_ = _tmp21_->name;
						if (g_strcmp0 (_tmp22_, "gettext-domain") == 0) {
							xmlAttr* _tmp23_;
							xmlNode* _tmp24_;
							const gchar* _tmp25_;
							_tmp23_ = prop;
							_tmp24_ = _tmp23_->children;
							_tmp25_ = _tmp24_->content;
							gettext_domain = _tmp25_;
						} else {
							xmlAttr* _tmp26_;
							const gchar* _tmp27_;
							_tmp26_ = prop;
							_tmp27_ = _tmp26_->name;
							g_warning ("dconf-schema.vala:330: Unknown property on <schema>, %s", _tmp27_);
						}
					}
				}
			}
		}
	}
	{
		xmlNode* _tmp28_;
		xmlNode* _tmp29_;
		xmlNode* child;
		_tmp28_ = node;
		_tmp29_ = _tmp28_->children;
		child = _tmp29_;
		{
			gboolean _tmp30_;
			_tmp30_ = TRUE;
			while (TRUE) {
				gboolean _tmp31_;
				xmlNode* _tmp34_;
				xmlNode* _tmp35_;
				const gchar* _tmp36_;
				xmlNode* _tmp37_;
				const gchar* _tmp38_;
				SchemaKey* _tmp39_;
				SchemaKey* key;
				GHashTable* _tmp40_;
				SchemaKey* _tmp41_;
				const gchar* _tmp42_;
				gchar* _tmp43_;
				SchemaKey* _tmp44_;
				SchemaKey* _tmp45_;
				_tmp31_ = _tmp30_;
				if (!_tmp31_) {
					xmlNode* _tmp32_;
					xmlNode* _tmp33_;
					_tmp32_ = child;
					_tmp33_ = _tmp32_->next;
					child = _tmp33_;
				}
				_tmp30_ = FALSE;
				_tmp34_ = child;
				if (!(_tmp34_ != NULL)) {
					break;
				}
				_tmp35_ = child;
				_tmp36_ = _tmp35_->name;
				if (g_strcmp0 (_tmp36_, "key") != 0) {
					continue;
				}
				_tmp37_ = child;
				_tmp38_ = gettext_domain;
				_tmp39_ = schema_key_new_from_xml (_tmp37_, self, _tmp38_);
				key = _tmp39_;
				_tmp40_ = self->keys;
				_tmp41_ = key;
				_tmp42_ = _tmp41_->name;
				_tmp43_ = g_strdup (_tmp42_);
				_tmp44_ = key;
				_tmp45_ = _schema_key_ref0 (_tmp44_);
				g_hash_table_insert (_tmp40_, _tmp43_, _tmp45_);
				_schema_key_unref0 (key);
			}
		}
	}
	return self;
}


Schema* schema_new_from_xml (SchemaList* list, xmlNode* node, const gchar* gettext_domain) {
	return schema_construct_from_xml (TYPE_SCHEMA, list, node, gettext_domain);
}


Schema* schema_construct (GType object_type) {
	Schema* self = NULL;
	self = (Schema*) g_type_create_instance (object_type);
	return self;
}


Schema* schema_new (void) {
	return schema_construct (TYPE_SCHEMA);
}


static void value_schema_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_unref (value->data[0].v_pointer);
	}
}


static void value_schema_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Schema* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Schema** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchema* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema (GValue* value, gpointer v_object) {
	Schema* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_unref (old);
	}
}


void value_take_schema (GValue* value, gpointer v_object) {
	Schema* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_unref (old);
	}
}


static void schema_class_init (SchemaClass * klass) {
	schema_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_CLASS (klass)->finalize = schema_finalize;
}


static void schema_instance_init (Schema * self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _schema_key_unref0_);
	self->keys = _tmp2_;
	self->ref_count = 1;
}


static void schema_finalize (Schema* obj) {
	Schema * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA, Schema);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	_g_free0 (self->path);
	_g_hash_table_unref0 (self->keys);
}


GType schema_get_type (void) {
	static volatile gsize schema_type_id__volatile = 0;
	if (g_once_init_enter (&schema_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_init, value_schema_free_value, value_schema_copy_value, value_schema_peek_pointer, "p", value_schema_collect_value, "p", value_schema_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Schema), 0, (GInstanceInitFunc) schema_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_type_id;
		schema_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Schema", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_type_id__volatile, schema_type_id);
	}
	return schema_type_id__volatile;
}


gpointer schema_ref (gpointer instance) {
	Schema* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_unref (gpointer instance) {
	Schema* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _schema_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_unref (var), NULL));
}


static void _g_list_free__schema_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _schema_unref0_, NULL);
	g_list_free (self);
}


static void _schema_enum_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_enum_unref (var), NULL));
}


static void _schema_flags_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_flags_unref (var), NULL));
}


static gpointer _schema_enum_ref0 (gpointer self) {
	return self ? schema_enum_ref (self) : NULL;
}


static gpointer _schema_flags_ref0 (gpointer self) {
	return self ? schema_flags_ref (self) : NULL;
}


void schema_list_parse_file (SchemaList* self, const gchar* path) {
	const gchar* _tmp0_;
	xmlDoc* _tmp1_ = NULL;
	xmlDoc* doc;
	xmlDoc* _tmp2_;
	xmlDoc* _tmp3_;
	xmlNode* _tmp4_ = NULL;
	xmlNode* root;
	xmlNode* _tmp5_;
	xmlNode* _tmp6_;
	const gchar* _tmp7_;
	gchar* gettext_domain;
	xmlDoc* _tmp76_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = xmlParseFile (_tmp0_);
	doc = _tmp1_;
	_tmp2_ = doc;
	if (_tmp2_ == NULL) {
		return;
	}
	_tmp3_ = doc;
	_tmp4_ = xmlDocGetRootElement (_tmp3_);
	root = _tmp4_;
	_tmp5_ = root;
	if (_tmp5_ == NULL) {
		return;
	}
	_tmp6_ = root;
	_tmp7_ = _tmp6_->name;
	if (g_strcmp0 (_tmp7_, "schemalist") != 0) {
		return;
	}
	gettext_domain = NULL;
	{
		xmlNode* _tmp8_;
		xmlAttr* _tmp9_;
		xmlAttr* prop;
		_tmp8_ = root;
		_tmp9_ = _tmp8_->properties;
		prop = _tmp9_;
		{
			gboolean _tmp10_;
			_tmp10_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_;
				xmlAttr* _tmp14_;
				xmlAttr* _tmp15_;
				const gchar* _tmp16_;
				_tmp11_ = _tmp10_;
				if (!_tmp11_) {
					xmlAttr* _tmp12_;
					xmlAttr* _tmp13_;
					_tmp12_ = prop;
					_tmp13_ = _tmp12_->next;
					prop = _tmp13_;
				}
				_tmp10_ = FALSE;
				_tmp14_ = prop;
				if (!(_tmp14_ != NULL)) {
					break;
				}
				_tmp15_ = prop;
				_tmp16_ = _tmp15_->name;
				if (g_strcmp0 (_tmp16_, "gettext-domain") == 0) {
					xmlAttr* _tmp17_;
					xmlNode* _tmp18_;
					const gchar* _tmp19_;
					gchar* _tmp20_;
					_tmp17_ = prop;
					_tmp18_ = _tmp17_->children;
					_tmp19_ = _tmp18_->content;
					_tmp20_ = g_strdup (_tmp19_);
					_g_free0 (gettext_domain);
					gettext_domain = _tmp20_;
				}
			}
		}
	}
	{
		xmlNode* _tmp21_;
		xmlNode* _tmp22_;
		xmlNode* node;
		_tmp21_ = root;
		_tmp22_ = _tmp21_->children;
		node = _tmp22_;
		{
			gboolean _tmp23_;
			_tmp23_ = TRUE;
			while (TRUE) {
				gboolean _tmp24_;
				xmlNode* _tmp27_;
				xmlNode* _tmp28_;
				const gchar* _tmp29_;
				_tmp24_ = _tmp23_;
				if (!_tmp24_) {
					xmlNode* _tmp25_;
					xmlNode* _tmp26_;
					_tmp25_ = node;
					_tmp26_ = _tmp25_->next;
					node = _tmp26_;
				}
				_tmp23_ = FALSE;
				_tmp27_ = node;
				if (!(_tmp27_ != NULL)) {
					break;
				}
				_tmp28_ = node;
				_tmp29_ = _tmp28_->name;
				if (g_strcmp0 (_tmp29_, "schema") == 0) {
					xmlNode* _tmp30_;
					const gchar* _tmp31_;
					Schema* _tmp32_;
					Schema* schema;
					Schema* _tmp33_;
					const gchar* _tmp34_;
					Schema* _tmp35_;
					GHashTable* _tmp36_;
					GList* _tmp37_ = NULL;
					Schema* _tmp48_;
					Schema* _tmp49_;
					_tmp30_ = node;
					_tmp31_ = gettext_domain;
					_tmp32_ = schema_new_from_xml (self, _tmp30_, _tmp31_);
					schema = _tmp32_;
					_tmp33_ = schema;
					_tmp34_ = _tmp33_->path;
					if (_tmp34_ == NULL) {
						_schema_unref0 (schema);
						continue;
					}
					_tmp35_ = schema;
					_tmp36_ = _tmp35_->keys;
					_tmp37_ = g_hash_table_get_values (_tmp36_);
					{
						GList* key_collection = NULL;
						GList* key_it = NULL;
						key_collection = _tmp37_;
						for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
							SchemaKey* key = NULL;
							key = (SchemaKey*) key_it->data;
							{
								Schema* _tmp38_;
								const gchar* _tmp39_;
								SchemaKey* _tmp40_;
								const gchar* _tmp41_;
								gchar* _tmp42_;
								gchar* full_name;
								GHashTable* _tmp43_;
								const gchar* _tmp44_;
								gchar* _tmp45_;
								SchemaKey* _tmp46_;
								SchemaKey* _tmp47_;
								_tmp38_ = schema;
								_tmp39_ = _tmp38_->path;
								_tmp40_ = key;
								_tmp41_ = _tmp40_->name;
								_tmp42_ = g_strconcat (_tmp39_, _tmp41_, NULL);
								full_name = _tmp42_;
								_tmp43_ = self->keys;
								_tmp44_ = full_name;
								_tmp45_ = g_strdup (_tmp44_);
								_tmp46_ = key;
								_tmp47_ = _schema_key_ref0 (_tmp46_);
								g_hash_table_insert (_tmp43_, _tmp45_, _tmp47_);
								_g_free0 (full_name);
							}
						}
						_g_list_free0 (key_collection);
					}
					_tmp48_ = schema;
					_tmp49_ = _schema_ref0 (_tmp48_);
					self->schemas = g_list_append (self->schemas, _tmp49_);
					_schema_unref0 (schema);
				} else {
					xmlNode* _tmp50_;
					const gchar* _tmp51_;
					_tmp50_ = node;
					_tmp51_ = _tmp50_->name;
					if (g_strcmp0 (_tmp51_, "enum") == 0) {
						xmlNode* _tmp52_;
						SchemaEnum* _tmp53_;
						SchemaEnum* _enum_;
						GHashTable* _tmp54_;
						SchemaEnum* _tmp55_;
						const gchar* _tmp56_;
						gchar* _tmp57_;
						SchemaEnum* _tmp58_;
						SchemaEnum* _tmp59_;
						_tmp52_ = node;
						_tmp53_ = schema_enum_new_from_xml (self, _tmp52_);
						_enum_ = _tmp53_;
						_tmp54_ = self->enums;
						_tmp55_ = _enum_;
						_tmp56_ = _tmp55_->id;
						_tmp57_ = g_strdup (_tmp56_);
						_tmp58_ = _enum_;
						_tmp59_ = _schema_enum_ref0 (_tmp58_);
						g_hash_table_insert (_tmp54_, _tmp57_, _tmp59_);
						_schema_enum_unref0 (_enum_);
					} else {
						xmlNode* _tmp60_;
						const gchar* _tmp61_;
						_tmp60_ = node;
						_tmp61_ = _tmp60_->name;
						if (g_strcmp0 (_tmp61_, "flags") == 0) {
							xmlNode* _tmp62_;
							SchemaFlags* _tmp63_;
							SchemaFlags* f;
							GHashTable* _tmp64_;
							SchemaFlags* _tmp65_;
							const gchar* _tmp66_;
							gchar* _tmp67_;
							SchemaFlags* _tmp68_;
							SchemaFlags* _tmp69_;
							_tmp62_ = node;
							_tmp63_ = schema_flags_new_from_xml (self, _tmp62_);
							f = _tmp63_;
							_tmp64_ = self->flags;
							_tmp65_ = f;
							_tmp66_ = _tmp65_->id;
							_tmp67_ = g_strdup (_tmp66_);
							_tmp68_ = f;
							_tmp69_ = _schema_flags_ref0 (_tmp68_);
							g_hash_table_insert (_tmp64_, _tmp67_, _tmp69_);
							_schema_flags_unref0 (f);
						} else {
							xmlNode* _tmp70_;
							xmlElementType _tmp71_;
							_tmp70_ = node;
							_tmp71_ = _tmp70_->type;
							if (_tmp71_ == XML_COMMENT_NODE) {
							} else {
								xmlNode* _tmp72_;
								xmlElementType _tmp73_;
								_tmp72_ = node;
								_tmp73_ = _tmp72_->type;
								if (_tmp73_ != XML_TEXT_NODE) {
									xmlNode* _tmp74_;
									const gchar* _tmp75_;
									_tmp74_ = node;
									_tmp75_ = _tmp74_->name;
									g_warning ("dconf-schema.vala:404: Unknown tag <%s>", _tmp75_);
								}
							}
						}
					}
				}
			}
		}
	}
	_tmp76_ = doc;
	xmlFreeDoc (_tmp76_);
	_g_free0 (gettext_domain);
}


void schema_list_load_directory (SchemaList* self, const gchar* dir, GError** error) {
	const gchar* _tmp0_;
	GFile* _tmp1_ = NULL;
	GFile* directory;
	GFile* _tmp2_;
	GFileEnumerator* _tmp3_ = NULL;
	GFileEnumerator* i;
	GFileInfo* info = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	_tmp0_ = dir;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = g_file_enumerate_children (_tmp2_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	i = _tmp3_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (directory);
		return;
	}
	while (TRUE) {
		GFileEnumerator* _tmp4_;
		GFileInfo* _tmp5_ = NULL;
		GFileInfo* _tmp6_;
		GFileInfo* _tmp7_;
		GFileInfo* _tmp8_;
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gchar* name;
		gboolean _tmp11_ = FALSE;
		const gchar* _tmp12_;
		gboolean _tmp13_ = FALSE;
		gboolean _tmp16_;
		const gchar* _tmp17_;
		const gchar* _tmp18_;
		gchar* _tmp19_ = NULL;
		gchar* path;
		const gchar* _tmp20_;
		_tmp4_ = i;
		_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error_);
		_tmp6_ = _tmp5_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (info);
			_g_object_unref0 (i);
			_g_object_unref0 (directory);
			return;
		}
		_g_object_unref0 (info);
		info = _tmp6_;
		_tmp7_ = info;
		if (!(_tmp7_ != NULL)) {
			break;
		}
		_tmp8_ = info;
		_tmp9_ = g_file_info_get_name (_tmp8_);
		_tmp10_ = g_strdup (_tmp9_);
		name = _tmp10_;
		_tmp12_ = name;
		_tmp13_ = g_str_has_suffix (_tmp12_, ".gschema.xml");
		if (!_tmp13_) {
			const gchar* _tmp14_;
			gboolean _tmp15_ = FALSE;
			_tmp14_ = name;
			_tmp15_ = g_str_has_suffix (_tmp14_, ".enums.xml");
			_tmp11_ = !_tmp15_;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp16_ = _tmp11_;
		if (_tmp16_) {
			_g_free0 (name);
			continue;
		}
		_tmp17_ = dir;
		_tmp18_ = name;
		_tmp19_ = g_build_filename (_tmp17_, _tmp18_, NULL, NULL);
		path = _tmp19_;
		_tmp20_ = path;
		schema_list_parse_file (self, _tmp20_);
		_g_free0 (path);
		_g_free0 (name);
	}
	_g_object_unref0 (info);
	_g_object_unref0 (i);
	_g_object_unref0 (directory);
}


SchemaList* schema_list_construct (GType object_type) {
	SchemaList* self = NULL;
	self = (SchemaList*) g_type_create_instance (object_type);
	return self;
}


SchemaList* schema_list_new (void) {
	return schema_list_construct (TYPE_SCHEMA_LIST);
}


static void value_schema_list_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_list_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_list_unref (value->data[0].v_pointer);
	}
}


static void value_schema_list_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_list_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_list_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_list_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaList* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_list_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_list_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaList** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_list_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaList* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_LIST), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_list (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_list (GValue* value, gpointer v_object) {
	SchemaList* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_LIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_list_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_list_unref (old);
	}
}


void value_take_schema_list (GValue* value, gpointer v_object) {
	SchemaList* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_LIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_list_unref (old);
	}
}


static void schema_list_class_init (SchemaListClass * klass) {
	schema_list_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_LIST_CLASS (klass)->finalize = schema_list_finalize;
}


static void schema_list_instance_init (SchemaList * self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashFunc _tmp3_;
	GEqualFunc _tmp4_;
	GHashTable* _tmp5_;
	GHashFunc _tmp6_;
	GEqualFunc _tmp7_;
	GHashTable* _tmp8_;
	self->schemas = NULL;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _schema_key_unref0_);
	self->keys = _tmp2_;
	_tmp3_ = g_str_hash;
	_tmp4_ = g_str_equal;
	_tmp5_ = g_hash_table_new_full (_tmp3_, _tmp4_, _g_free0_, _schema_enum_unref0_);
	self->enums = _tmp5_;
	_tmp6_ = g_str_hash;
	_tmp7_ = g_str_equal;
	_tmp8_ = g_hash_table_new_full (_tmp6_, _tmp7_, _g_free0_, _schema_flags_unref0_);
	self->flags = _tmp8_;
	self->ref_count = 1;
}


static void schema_list_finalize (SchemaList* obj) {
	SchemaList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_LIST, SchemaList);
	__g_list_free__schema_unref0_0 (self->schemas);
	_g_hash_table_unref0 (self->keys);
	_g_hash_table_unref0 (self->enums);
	_g_hash_table_unref0 (self->flags);
}


GType schema_list_get_type (void) {
	static volatile gsize schema_list_type_id__volatile = 0;
	if (g_once_init_enter (&schema_list_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_list_init, value_schema_list_free_value, value_schema_list_copy_value, value_schema_list_peek_pointer, "p", value_schema_list_collect_value, "p", value_schema_list_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaList), 0, (GInstanceInitFunc) schema_list_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_list_type_id;
		schema_list_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaList", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_list_type_id__volatile, schema_list_type_id);
	}
	return schema_list_type_id__volatile;
}


gpointer schema_list_ref (gpointer instance) {
	SchemaList* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_list_unref (gpointer instance) {
	SchemaList* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_LIST_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



