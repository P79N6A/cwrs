/* dconf-editor.c generated by valac 0.18.0, the Vala compiler
 * generated from dconf-editor.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>
#include <locale.h>


#define TYPE_CONFIGURATION_EDITOR (configuration_editor_get_type ())
#define CONFIGURATION_EDITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIGURATION_EDITOR, ConfigurationEditor))
#define CONFIGURATION_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIGURATION_EDITOR, ConfigurationEditorClass))
#define IS_CONFIGURATION_EDITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIGURATION_EDITOR))
#define IS_CONFIGURATION_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIGURATION_EDITOR))
#define CONFIGURATION_EDITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIGURATION_EDITOR, ConfigurationEditorClass))

typedef struct _ConfigurationEditor ConfigurationEditor;
typedef struct _ConfigurationEditorClass ConfigurationEditorClass;
typedef struct _ConfigurationEditorPrivate ConfigurationEditorPrivate;

#define TYPE_SETTINGS_MODEL (settings_model_get_type ())
#define SETTINGS_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_MODEL, SettingsModel))
#define SETTINGS_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_MODEL, SettingsModelClass))
#define IS_SETTINGS_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_MODEL))
#define IS_SETTINGS_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_MODEL))
#define SETTINGS_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_MODEL, SettingsModelClass))

typedef struct _SettingsModel SettingsModel;
typedef struct _SettingsModelClass SettingsModelClass;

#define TYPE_KEY (key_get_type ())
#define KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY, Key))
#define KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY, KeyClass))
#define IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY))
#define IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY))
#define KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY, KeyClass))

typedef struct _Key Key;
typedef struct _KeyClass KeyClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_DCONF_DIR_VIEW (dconf_dir_view_get_type ())
#define DCONF_DIR_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DCONF_DIR_VIEW, DConfDirView))
#define DCONF_DIR_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DCONF_DIR_VIEW, DConfDirViewClass))
#define IS_DCONF_DIR_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DCONF_DIR_VIEW))
#define IS_DCONF_DIR_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DCONF_DIR_VIEW))
#define DCONF_DIR_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DCONF_DIR_VIEW, DConfDirViewClass))

typedef struct _DConfDirView DConfDirView;
typedef struct _DConfDirViewClass DConfDirViewClass;

#define TYPE_DCONF_KEY_VIEW (dconf_key_view_get_type ())
#define DCONF_KEY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DCONF_KEY_VIEW, DConfKeyView))
#define DCONF_KEY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DCONF_KEY_VIEW, DConfKeyViewClass))
#define IS_DCONF_KEY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DCONF_KEY_VIEW))
#define IS_DCONF_KEY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DCONF_KEY_VIEW))
#define DCONF_KEY_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DCONF_KEY_VIEW, DConfKeyViewClass))

typedef struct _DConfKeyView DConfKeyView;
typedef struct _DConfKeyViewClass DConfKeyViewClass;

#define TYPE_KEY_MODEL (key_model_get_type ())
#define KEY_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_MODEL, KeyModel))
#define KEY_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_MODEL, KeyModelClass))
#define IS_KEY_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_MODEL))
#define IS_KEY_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_MODEL))
#define KEY_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_MODEL, KeyModelClass))

typedef struct _KeyModel KeyModel;
typedef struct _KeyModelClass KeyModelClass;

#define TYPE_DIRECTORY (directory_get_type ())
#define DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DIRECTORY, Directory))
#define DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DIRECTORY, DirectoryClass))
#define IS_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DIRECTORY))
#define IS_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DIRECTORY))
#define DIRECTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DIRECTORY, DirectoryClass))

typedef struct _Directory Directory;
typedef struct _DirectoryClass DirectoryClass;
typedef struct _KeyPrivate KeyPrivate;

#define TYPE_SCHEMA_KEY (schema_key_get_type ())
#define SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_KEY, SchemaKey))
#define SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_KEY, SchemaKeyClass))
#define IS_SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_KEY))
#define IS_SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_KEY))
#define SCHEMA_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_KEY, SchemaKeyClass))

typedef struct _SchemaKey SchemaKey;
typedef struct _SchemaKeyClass SchemaKeyClass;
typedef struct _SchemaKeyPrivate SchemaKeyPrivate;

#define TYPE_SCHEMA (schema_get_type ())
#define SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA, Schema))
#define SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA, SchemaClass))
#define IS_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA))
#define IS_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA))
#define SCHEMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA, SchemaClass))

typedef struct _Schema Schema;
typedef struct _SchemaClass SchemaClass;

#define TYPE_SCHEMA_VALUE_RANGE (schema_value_range_get_type ())
#define SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange))
#define SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))
#define IS_SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE_RANGE))
#define IS_SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE_RANGE))
#define SCHEMA_VALUE_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))

typedef struct _SchemaValueRange SchemaValueRange;
typedef struct _SchemaValueRangeClass SchemaValueRangeClass;

#define TYPE_SCHEMA_CHOICE (schema_choice_get_type ())
#define SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_CHOICE, SchemaChoice))
#define SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))
#define IS_SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_CHOICE))
#define IS_SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_CHOICE))
#define SCHEMA_CHOICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))

typedef struct _SchemaChoice SchemaChoice;
typedef struct _SchemaChoiceClass SchemaChoiceClass;
typedef struct _SchemaValueRangePrivate SchemaValueRangePrivate;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
typedef struct _SchemaPrivate SchemaPrivate;

#define TYPE_SCHEMA_LIST (schema_list_get_type ())
#define SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_LIST, SchemaList))
#define SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_LIST, SchemaListClass))
#define IS_SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_LIST))
#define IS_SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_LIST))
#define SCHEMA_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_LIST, SchemaListClass))

typedef struct _SchemaList SchemaList;
typedef struct _SchemaListClass SchemaListClass;
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))

struct _ConfigurationEditor {
	GtkApplication parent_instance;
	ConfigurationEditorPrivate * priv;
};

struct _ConfigurationEditorClass {
	GtkApplicationClass parent_class;
};

struct _ConfigurationEditorPrivate {
	SettingsModel* model;
	GSettings* settings;
	GtkBuilder* ui;
	GtkApplicationWindow* window;
	GtkTreeView* dir_tree_view;
	GtkTreeView* key_tree_view;
	GtkGrid* key_info_grid;
	GtkLabel* schema_label;
	GtkLabel* summary_label;
	GtkLabel* description_label;
	GtkLabel* type_label;
	GtkLabel* default_label;
	GtkAction* set_default_action;
	GtkBox* search_box;
	GtkEntry* search_entry;
	GtkLabel* search_label;
	Key* selected_key;
};

struct _Key {
	GObject parent_instance;
	KeyPrivate * priv;
	Directory* parent;
	gchar* name;
	gchar* full_name;
	SchemaKey* schema;
};

struct _KeyClass {
	GObjectClass parent_class;
};

struct _SchemaKey {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaKeyPrivate * priv;
	Schema* schema;
	gchar* name;
	gchar* type;
	GVariant* default_value;
	SchemaValueRange* range;
	SchemaValueRange* type_range;
	GList* choices;
	gchar* enum_name;
	gchar* summary;
	gchar* description;
	gchar* gettext_domain;
};

struct _SchemaKeyClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaKey *self);
};

struct _SchemaValueRange {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaValueRangePrivate * priv;
	GVariant* min;
	GVariant* max;
};

struct _SchemaValueRangeClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaValueRange *self);
};

struct _Schema {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaPrivate * priv;
	SchemaList* list;
	gchar* id;
	gchar* path;
	GHashTable* keys;
};

struct _SchemaClass {
	GTypeClass parent_class;
	void (*finalize) (Schema *self);
};


static gpointer configuration_editor_parent_class = NULL;

GType configuration_editor_get_type (void) G_GNUC_CONST;
GType settings_model_get_type (void) G_GNUC_CONST;
GType key_get_type (void) G_GNUC_CONST;
#define CONFIGURATION_EDITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CONFIGURATION_EDITOR, ConfigurationEditorPrivate))
enum  {
	CONFIGURATION_EDITOR_DUMMY_PROPERTY
};
static void configuration_editor_find_cb (ConfigurationEditor* self);
static void _configuration_editor_find_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void configuration_editor_about_cb (ConfigurationEditor* self);
static void _configuration_editor_about_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void configuration_editor_quit_cb (ConfigurationEditor* self);
static void _configuration_editor_quit_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
ConfigurationEditor* configuration_editor_new (void);
ConfigurationEditor* configuration_editor_construct (GType object_type);
static void configuration_editor_real_startup (GApplication* base);
SettingsModel* settings_model_new (void);
SettingsModel* settings_model_construct (GType object_type);
static gboolean configuration_editor_main_window_window_state_event_cb (ConfigurationEditor* self, GtkWidget* widget, GdkEventWindowState* event);
static gboolean _configuration_editor_main_window_window_state_event_cb_gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self);
static gboolean configuration_editor_main_window_configure_event_cb (ConfigurationEditor* self, GtkWidget* widget, GdkEventConfigure* event);
static gboolean _configuration_editor_main_window_configure_event_cb_gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
DConfDirView* dconf_dir_view_new (void);
DConfDirView* dconf_dir_view_construct (GType object_type);
GType dconf_dir_view_get_type (void) G_GNUC_CONST;
static void configuration_editor_dir_selected_cb (ConfigurationEditor* self);
static void _configuration_editor_dir_selected_cb_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
DConfKeyView* dconf_key_view_new (void);
DConfKeyView* dconf_key_view_construct (GType object_type);
GType dconf_key_view_get_type (void) G_GNUC_CONST;
static void configuration_editor_key_selected_cb (ConfigurationEditor* self);
static void _configuration_editor_key_selected_cb_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
static void configuration_editor_set_default_cb (ConfigurationEditor* self, GtkAction* action);
static void _configuration_editor_set_default_cb_gtk_action_activate (GtkAction* _sender, gpointer self);
static void configuration_editor_find_next_cb (ConfigurationEditor* self);
static void _configuration_editor_find_next_cb_gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void configuration_editor_close_search_cb (ConfigurationEditor* self);
static void _configuration_editor_close_search_cb_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void _configuration_editor_find_next_cb_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void configuration_editor_real_activate (GApplication* base);
GType key_model_get_type (void) G_GNUC_CONST;
GType directory_get_type (void) G_GNUC_CONST;
Directory* settings_model_get_directory (SettingsModel* self, GtkTreeIter* iter);
KeyModel* directory_get_key_model (Directory* self);
static gchar* configuration_editor_key_to_description (ConfigurationEditor* self, Key* key);
gpointer schema_key_ref (gpointer instance);
void schema_key_unref (gpointer instance);
GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_key (GValue* value, gpointer v_object);
void value_take_schema_key (GValue* value, gpointer v_object);
gpointer value_get_schema_key (const GValue* value);
GType schema_key_get_type (void) G_GNUC_CONST;
gpointer schema_ref (gpointer instance);
void schema_unref (gpointer instance);
GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema (GValue* value, gpointer v_object);
void value_take_schema (GValue* value, gpointer v_object);
gpointer value_get_schema (const GValue* value);
GType schema_get_type (void) G_GNUC_CONST;
gpointer schema_value_range_ref (gpointer instance);
void schema_value_range_unref (gpointer instance);
GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_value_range (GValue* value, gpointer v_object);
void value_take_schema_value_range (GValue* value, gpointer v_object);
gpointer value_get_schema_value_range (const GValue* value);
GType schema_value_range_get_type (void) G_GNUC_CONST;
gpointer schema_choice_ref (gpointer instance);
void schema_choice_unref (gpointer instance);
GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_choice (GValue* value, gpointer v_object);
void value_take_schema_choice (GValue* value, gpointer v_object);
gpointer value_get_schema_choice (const GValue* value);
GType schema_choice_get_type (void) G_GNUC_CONST;
GVariant* key_get_min (Key* self);
GVariant* key_get_max (Key* self);
static void configuration_editor_key_changed_cb (ConfigurationEditor* self, Key* key);
static void _configuration_editor_key_changed_cb_key_value_changed (Key* _sender, gpointer self);
Key* key_model_get_key (KeyModel* self, GtkTreeIter* iter);
gboolean key_get_is_default (Key* self);
gpointer schema_list_ref (gpointer instance);
void schema_list_unref (gpointer instance);
GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_list (GValue* value, gpointer v_object);
void value_take_schema_list (GValue* value, gpointer v_object);
gpointer value_get_schema_list (const GValue* value);
GType schema_list_get_type (void) G_GNUC_CONST;
void key_set_to_default (Key* self);
static gboolean configuration_editor_get_next_iter (ConfigurationEditor* self, GtkTreeIter* iter);
gint configuration_editor_main (gchar** args, int args_length1);
static void configuration_editor_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GActionEntry CONFIGURATION_EDITOR_action_entries[3] = {{"find", _configuration_editor_find_cb_gsimple_action_activate_callback}, {"about", _configuration_editor_about_cb_gsimple_action_activate_callback}, {"quit", _configuration_editor_quit_cb_gsimple_action_activate_callback}};

static void _configuration_editor_find_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	configuration_editor_find_cb (self);
}


static void _configuration_editor_about_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	configuration_editor_about_cb (self);
}


static void _configuration_editor_quit_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	configuration_editor_quit_cb (self);
}


ConfigurationEditor* configuration_editor_construct (GType object_type) {
	ConfigurationEditor * self = NULL;
	self = (ConfigurationEditor*) g_object_new (object_type, "application-id", "ca.desrt.dconf-editor", "flags", G_APPLICATION_FLAGS_NONE, NULL);
	return self;
}


ConfigurationEditor* configuration_editor_new (void) {
	return configuration_editor_construct (TYPE_CONFIGURATION_EDITOR);
}


static gboolean _configuration_editor_main_window_window_state_event_cb_gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self) {
	gboolean result;
	result = configuration_editor_main_window_window_state_event_cb (self, _sender, event);
	return result;
}


static gboolean _configuration_editor_main_window_configure_event_cb_gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = configuration_editor_main_window_configure_event_cb (self, _sender, event);
	return result;
}


static void _configuration_editor_dir_selected_cb_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	configuration_editor_dir_selected_cb (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _configuration_editor_key_selected_cb_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	configuration_editor_key_selected_cb (self);
}


static void _configuration_editor_set_default_cb_gtk_action_activate (GtkAction* _sender, gpointer self) {
	configuration_editor_set_default_cb (self, _sender);
}


static void _configuration_editor_find_next_cb_gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	configuration_editor_find_next_cb (self);
}


static void _configuration_editor_close_search_cb_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	configuration_editor_close_search_cb (self);
}


static void _configuration_editor_find_next_cb_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	configuration_editor_find_next_cb (self);
}


static void configuration_editor_real_startup (GApplication* base) {
	ConfigurationEditor * self;
	const gchar* _tmp0_ = NULL;
	GSettings* _tmp1_;
	SettingsModel* _tmp2_;
	GtkBuilder* _tmp3_;
	GtkApplicationWindow* _tmp12_;
	GtkApplicationWindow* _tmp13_;
	GtkApplicationWindow* _tmp14_;
	const gchar* _tmp15_ = NULL;
	GtkApplicationWindow* _tmp16_;
	GtkApplicationWindow* _tmp17_;
	GtkApplicationWindow* _tmp18_;
	GtkBuilder* _tmp19_;
	GObject* _tmp20_ = NULL;
	GtkBuilder* _tmp21_;
	GtkBuilder* menu_ui;
	GObject* _tmp25_ = NULL;
	GtkApplicationWindow* _tmp26_;
	GSettings* _tmp27_;
	gint _tmp28_ = 0;
	GSettings* _tmp29_;
	gint _tmp30_ = 0;
	GSettings* _tmp31_;
	gboolean _tmp32_ = FALSE;
	DConfDirView* _tmp34_;
	GtkTreeView* _tmp35_;
	SettingsModel* _tmp36_;
	GtkTreeView* _tmp37_;
	GtkTreeSelection* _tmp38_ = NULL;
	GtkTreeView* _tmp39_;
	GtkBuilder* _tmp40_;
	GObject* _tmp41_ = NULL;
	GtkScrolledWindow* _tmp42_;
	GtkScrolledWindow* scroll;
	GtkScrolledWindow* _tmp43_;
	GtkTreeView* _tmp44_;
	DConfKeyView* _tmp45_;
	GtkTreeView* _tmp46_;
	GtkTreeView* _tmp47_;
	GtkTreeSelection* _tmp48_ = NULL;
	GtkBuilder* _tmp49_;
	GObject* _tmp50_ = NULL;
	GtkScrolledWindow* _tmp51_;
	GtkScrolledWindow* _tmp52_;
	GtkTreeView* _tmp53_;
	GtkBuilder* _tmp54_;
	GObject* _tmp55_ = NULL;
	GtkGrid* _tmp56_;
	GtkBuilder* _tmp57_;
	GObject* _tmp58_ = NULL;
	GtkLabel* _tmp59_;
	GtkBuilder* _tmp60_;
	GObject* _tmp61_ = NULL;
	GtkLabel* _tmp62_;
	GtkBuilder* _tmp63_;
	GObject* _tmp64_ = NULL;
	GtkLabel* _tmp65_;
	GtkBuilder* _tmp66_;
	GObject* _tmp67_ = NULL;
	GtkLabel* _tmp68_;
	GtkBuilder* _tmp69_;
	GObject* _tmp70_ = NULL;
	GtkLabel* _tmp71_;
	GtkBuilder* _tmp72_;
	GObject* _tmp73_ = NULL;
	GtkAction* _tmp74_;
	GtkAction* _tmp75_;
	GtkBuilder* _tmp76_;
	GObject* _tmp77_ = NULL;
	GtkBox* _tmp78_;
	GtkBuilder* _tmp79_;
	GObject* _tmp80_ = NULL;
	GtkEntry* _tmp81_;
	GtkBuilder* _tmp82_;
	GObject* _tmp83_ = NULL;
	GtkLabel* _tmp84_;
	GtkEntry* _tmp85_;
	GtkBuilder* _tmp86_;
	GObject* _tmp87_ = NULL;
	GtkButton* _tmp88_;
	GtkButton* search_box_close_button;
	GtkButton* _tmp89_;
	GtkBuilder* _tmp90_;
	GObject* _tmp91_ = NULL;
	GtkButton* _tmp92_;
	GtkButton* search_next_button;
	GtkButton* _tmp93_;
	GtkTreeIter iter = {0};
	SettingsModel* _tmp94_;
	GtkTreeIter _tmp95_ = {0};
	gboolean _tmp96_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (ConfigurationEditor*) base;
	G_APPLICATION_CLASS (configuration_editor_parent_class)->startup ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_APPLICATION, GtkApplication));
	_tmp0_ = _ ("dconf Editor");
	g_set_application_name (_tmp0_);
	g_action_map_add_action_entries ((GActionMap*) self, (const GActionEntry*) CONFIGURATION_EDITOR_action_entries, G_N_ELEMENTS (CONFIGURATION_EDITOR_action_entries), self);
	_tmp1_ = g_settings_new ("ca.desrt.dconf-editor.Settings");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp1_;
	_tmp2_ = settings_model_new ();
	_g_object_unref0 (self->priv->model);
	self->priv->model = _tmp2_;
	_tmp3_ = gtk_builder_new ();
	_g_object_unref0 (self->priv->ui);
	self->priv->ui = _tmp3_;
	{
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar** _tmp7_ = NULL;
		gchar** objects;
		gint objects_length1;
		gint _objects_size_;
		GtkBuilder* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		_tmp4_ = g_strdup ("set_default_action");
		_tmp5_ = g_strdup ("box1");
		_tmp6_ = g_strdup ("menu");
		_tmp7_ = g_new0 (gchar*, 3 + 1);
		_tmp7_[0] = _tmp4_;
		_tmp7_[1] = _tmp5_;
		_tmp7_[2] = _tmp6_;
		objects = _tmp7_;
		objects_length1 = 3;
		_objects_size_ = objects_length1;
		_tmp8_ = self->priv->ui;
		_tmp9_ = g_build_filename (PKGDATADIR, "dconf-editor.ui", NULL);
		_tmp10_ = _tmp9_;
		gtk_builder_add_objects_from_file (_tmp8_, _tmp10_, objects, &_inner_error_);
		_g_free0 (_tmp10_);
		if (_inner_error_ != NULL) {
			objects = (_vala_array_free (objects, objects_length1, (GDestroyNotify) g_free), NULL);
			goto __catch0_g_error;
		}
		objects = (_vala_array_free (objects, objects_length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp11_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp11_ = e->message;
		g_error ("dconf-editor.vala:55: Failed to load UI: %s", _tmp11_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp12_ = (GtkApplicationWindow*) gtk_application_window_new ((GtkApplication*) self);
	g_object_ref_sink (_tmp12_);
	_g_object_unref0 (self->priv->window);
	self->priv->window = _tmp12_;
	_tmp13_ = self->priv->window;
	gtk_window_set_default_size ((GtkWindow*) _tmp13_, 600, 300);
	_tmp14_ = self->priv->window;
	_tmp15_ = _ ("dconf Editor");
	gtk_window_set_title ((GtkWindow*) _tmp14_, _tmp15_);
	_tmp16_ = self->priv->window;
	g_signal_connect_object ((GtkWidget*) _tmp16_, "window-state-event", (GCallback) _configuration_editor_main_window_window_state_event_cb_gtk_widget_window_state_event, self, 0);
	_tmp17_ = self->priv->window;
	g_signal_connect_object ((GtkWidget*) _tmp17_, "configure-event", (GCallback) _configuration_editor_main_window_configure_event_cb_gtk_widget_configure_event, self, 0);
	_tmp18_ = self->priv->window;
	_tmp19_ = self->priv->ui;
	_tmp20_ = gtk_builder_get_object (_tmp19_, "box1");
	gtk_container_add ((GtkContainer*) _tmp18_, (GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp20_, GTK_TYPE_BOX, GtkBox));
	_tmp21_ = gtk_builder_new ();
	menu_ui = _tmp21_;
	{
		gchar* _tmp22_ = NULL;
		gchar* _tmp23_;
		_tmp22_ = g_build_filename (PKGDATADIR, "dconf-editor-menu.ui", NULL);
		_tmp23_ = _tmp22_;
		gtk_builder_add_from_file (menu_ui, _tmp23_, &_inner_error_);
		_g_free0 (_tmp23_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp24_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp24_ = e->message;
		g_error ("dconf-editor.vala:71: Failed to load menu UI: %s", _tmp24_);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (menu_ui);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp25_ = gtk_builder_get_object (menu_ui, "menu");
	gtk_application_set_app_menu ((GtkApplication*) self, G_TYPE_CHECK_INSTANCE_CAST (_tmp25_, g_menu_model_get_type (), GMenuModel));
	_tmp26_ = self->priv->window;
	_tmp27_ = self->priv->settings;
	_tmp28_ = g_settings_get_int (_tmp27_, "width");
	_tmp29_ = self->priv->settings;
	_tmp30_ = g_settings_get_int (_tmp29_, "height");
	gtk_window_set_default_size ((GtkWindow*) _tmp26_, _tmp28_, _tmp30_);
	_tmp31_ = self->priv->settings;
	_tmp32_ = g_settings_get_boolean (_tmp31_, "maximized");
	if (_tmp32_) {
		GtkApplicationWindow* _tmp33_;
		_tmp33_ = self->priv->window;
		gtk_window_maximize ((GtkWindow*) _tmp33_);
	}
	_tmp34_ = dconf_dir_view_new ();
	g_object_ref_sink (_tmp34_);
	_g_object_unref0 (self->priv->dir_tree_view);
	self->priv->dir_tree_view = (GtkTreeView*) _tmp34_;
	_tmp35_ = self->priv->dir_tree_view;
	_tmp36_ = self->priv->model;
	gtk_tree_view_set_model (_tmp35_, (GtkTreeModel*) _tmp36_);
	_tmp37_ = self->priv->dir_tree_view;
	_tmp38_ = gtk_tree_view_get_selection (_tmp37_);
	g_signal_connect_object (_tmp38_, "changed", (GCallback) _configuration_editor_dir_selected_cb_gtk_tree_selection_changed, self, 0);
	_tmp39_ = self->priv->dir_tree_view;
	gtk_widget_show ((GtkWidget*) _tmp39_);
	_tmp40_ = self->priv->ui;
	_tmp41_ = gtk_builder_get_object (_tmp40_, "directory_scrolledwindow");
	_tmp42_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp41_, GTK_TYPE_SCROLLED_WINDOW, GtkScrolledWindow));
	scroll = _tmp42_;
	_tmp43_ = scroll;
	_tmp44_ = self->priv->dir_tree_view;
	gtk_container_add ((GtkContainer*) _tmp43_, (GtkWidget*) _tmp44_);
	_tmp45_ = dconf_key_view_new ();
	g_object_ref_sink (_tmp45_);
	_g_object_unref0 (self->priv->key_tree_view);
	self->priv->key_tree_view = (GtkTreeView*) _tmp45_;
	_tmp46_ = self->priv->key_tree_view;
	gtk_widget_show ((GtkWidget*) _tmp46_);
	_tmp47_ = self->priv->key_tree_view;
	_tmp48_ = gtk_tree_view_get_selection (_tmp47_);
	g_signal_connect_object (_tmp48_, "changed", (GCallback) _configuration_editor_key_selected_cb_gtk_tree_selection_changed, self, 0);
	_tmp49_ = self->priv->ui;
	_tmp50_ = gtk_builder_get_object (_tmp49_, "key_scrolledwindow");
	_tmp51_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp50_, GTK_TYPE_SCROLLED_WINDOW, GtkScrolledWindow));
	_g_object_unref0 (scroll);
	scroll = _tmp51_;
	_tmp52_ = scroll;
	_tmp53_ = self->priv->key_tree_view;
	gtk_container_add ((GtkContainer*) _tmp52_, (GtkWidget*) _tmp53_);
	_tmp54_ = self->priv->ui;
	_tmp55_ = gtk_builder_get_object (_tmp54_, "key_info_grid");
	_tmp56_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp55_, GTK_TYPE_GRID, GtkGrid));
	_g_object_unref0 (self->priv->key_info_grid);
	self->priv->key_info_grid = _tmp56_;
	_tmp57_ = self->priv->ui;
	_tmp58_ = gtk_builder_get_object (_tmp57_, "schema_label");
	_tmp59_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp58_, GTK_TYPE_LABEL, GtkLabel));
	_g_object_unref0 (self->priv->schema_label);
	self->priv->schema_label = _tmp59_;
	_tmp60_ = self->priv->ui;
	_tmp61_ = gtk_builder_get_object (_tmp60_, "summary_label");
	_tmp62_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp61_, GTK_TYPE_LABEL, GtkLabel));
	_g_object_unref0 (self->priv->summary_label);
	self->priv->summary_label = _tmp62_;
	_tmp63_ = self->priv->ui;
	_tmp64_ = gtk_builder_get_object (_tmp63_, "description_label");
	_tmp65_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp64_, GTK_TYPE_LABEL, GtkLabel));
	_g_object_unref0 (self->priv->description_label);
	self->priv->description_label = _tmp65_;
	_tmp66_ = self->priv->ui;
	_tmp67_ = gtk_builder_get_object (_tmp66_, "type_label");
	_tmp68_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp67_, GTK_TYPE_LABEL, GtkLabel));
	_g_object_unref0 (self->priv->type_label);
	self->priv->type_label = _tmp68_;
	_tmp69_ = self->priv->ui;
	_tmp70_ = gtk_builder_get_object (_tmp69_, "default_label");
	_tmp71_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp70_, GTK_TYPE_LABEL, GtkLabel));
	_g_object_unref0 (self->priv->default_label);
	self->priv->default_label = _tmp71_;
	_tmp72_ = self->priv->ui;
	_tmp73_ = gtk_builder_get_object (_tmp72_, "set_default_action");
	_tmp74_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp73_, GTK_TYPE_ACTION, GtkAction));
	_g_object_unref0 (self->priv->set_default_action);
	self->priv->set_default_action = _tmp74_;
	_tmp75_ = self->priv->set_default_action;
	g_signal_connect_object (_tmp75_, "activate", (GCallback) _configuration_editor_set_default_cb_gtk_action_activate, self, 0);
	_tmp76_ = self->priv->ui;
	_tmp77_ = gtk_builder_get_object (_tmp76_, "search_box");
	_tmp78_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp77_, GTK_TYPE_BOX, GtkBox));
	_g_object_unref0 (self->priv->search_box);
	self->priv->search_box = _tmp78_;
	_tmp79_ = self->priv->ui;
	_tmp80_ = gtk_builder_get_object (_tmp79_, "search_entry");
	_tmp81_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp80_, GTK_TYPE_ENTRY, GtkEntry));
	_g_object_unref0 (self->priv->search_entry);
	self->priv->search_entry = _tmp81_;
	_tmp82_ = self->priv->ui;
	_tmp83_ = gtk_builder_get_object (_tmp82_, "search_label");
	_tmp84_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp83_, GTK_TYPE_LABEL, GtkLabel));
	_g_object_unref0 (self->priv->search_label);
	self->priv->search_label = _tmp84_;
	_tmp85_ = self->priv->search_entry;
	g_signal_connect_object (_tmp85_, "activate", (GCallback) _configuration_editor_find_next_cb_gtk_entry_activate, self, 0);
	_tmp86_ = self->priv->ui;
	_tmp87_ = gtk_builder_get_object (_tmp86_, "search_box_close_button");
	_tmp88_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp87_, GTK_TYPE_BUTTON, GtkButton));
	search_box_close_button = _tmp88_;
	_tmp89_ = search_box_close_button;
	g_signal_connect_object (_tmp89_, "clicked", (GCallback) _configuration_editor_close_search_cb_gtk_button_clicked, self, 0);
	_tmp90_ = self->priv->ui;
	_tmp91_ = gtk_builder_get_object (_tmp90_, "search_next_button");
	_tmp92_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp91_, GTK_TYPE_BUTTON, GtkButton));
	search_next_button = _tmp92_;
	_tmp93_ = search_next_button;
	g_signal_connect_object (_tmp93_, "clicked", (GCallback) _configuration_editor_find_next_cb_gtk_button_clicked, self, 0);
	_tmp94_ = self->priv->model;
	_tmp96_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) _tmp94_, &_tmp95_);
	iter = _tmp95_;
	if (_tmp96_) {
		GtkTreeView* _tmp97_;
		GtkTreeSelection* _tmp98_ = NULL;
		GtkTreeIter _tmp99_;
		_tmp97_ = self->priv->dir_tree_view;
		_tmp98_ = gtk_tree_view_get_selection (_tmp97_);
		_tmp99_ = iter;
		gtk_tree_selection_select_iter (_tmp98_, &_tmp99_);
	}
	_g_object_unref0 (search_next_button);
	_g_object_unref0 (search_box_close_button);
	_g_object_unref0 (scroll);
	_g_object_unref0 (menu_ui);
}


static void configuration_editor_close_search_cb (ConfigurationEditor* self) {
	GtkBox* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->search_box;
	gtk_widget_hide ((GtkWidget*) _tmp0_);
}


static void configuration_editor_real_activate (GApplication* base) {
	ConfigurationEditor * self;
	GtkApplicationWindow* _tmp0_;
	self = (ConfigurationEditor*) base;
	_tmp0_ = self->priv->window;
	gtk_window_present ((GtkWindow*) _tmp0_);
}


static void configuration_editor_dir_selected_cb (ConfigurationEditor* self) {
	KeyModel* key_model;
	GtkTreeIter iter = {0};
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeIter _tmp2_ = {0};
	gboolean _tmp3_ = FALSE;
	GtkTreeView* _tmp11_;
	KeyModel* _tmp12_;
	gboolean _tmp13_ = FALSE;
	KeyModel* _tmp14_;
	gboolean _tmp18_;
	g_return_if_fail (self != NULL);
	key_model = NULL;
	_tmp0_ = self->priv->dir_tree_view;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp3_ = gtk_tree_selection_get_selected (_tmp1_, NULL, &_tmp2_);
	iter = _tmp2_;
	if (_tmp3_) {
		SettingsModel* _tmp4_;
		GtkTreeIter _tmp5_;
		Directory* _tmp6_ = NULL;
		Directory* _tmp7_;
		KeyModel* _tmp8_;
		KeyModel* _tmp9_;
		KeyModel* _tmp10_;
		_tmp4_ = self->priv->model;
		_tmp5_ = iter;
		_tmp6_ = settings_model_get_directory (_tmp4_, &_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = directory_get_key_model (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = _g_object_ref0 (_tmp9_);
		_g_object_unref0 (key_model);
		key_model = _tmp10_;
		_g_object_unref0 (_tmp7_);
	}
	_tmp11_ = self->priv->key_tree_view;
	_tmp12_ = key_model;
	gtk_tree_view_set_model (_tmp11_, (GtkTreeModel*) _tmp12_);
	_tmp14_ = key_model;
	if (_tmp14_ != NULL) {
		KeyModel* _tmp15_;
		GtkTreeIter _tmp16_ = {0};
		gboolean _tmp17_ = FALSE;
		_tmp15_ = key_model;
		_tmp17_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) _tmp15_, &_tmp16_);
		iter = _tmp16_;
		_tmp13_ = _tmp17_;
	} else {
		_tmp13_ = FALSE;
	}
	_tmp18_ = _tmp13_;
	if (_tmp18_) {
		GtkTreeView* _tmp19_;
		GtkTreeSelection* _tmp20_ = NULL;
		GtkTreeIter _tmp21_;
		_tmp19_ = self->priv->key_tree_view;
		_tmp20_ = gtk_tree_view_get_selection (_tmp19_);
		_tmp21_ = iter;
		gtk_tree_selection_select_iter (_tmp20_, &_tmp21_);
	}
	_g_object_unref0 (key_model);
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


static gchar* configuration_editor_key_to_description (ConfigurationEditor* self, Key* key) {
	gchar* result = NULL;
	Key* _tmp0_;
	SchemaKey* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	GQuark _tmp5_ = 0U;
	static GQuark _tmp4_label0 = 0;
	static GQuark _tmp4_label1 = 0;
	static GQuark _tmp4_label2 = 0;
	static GQuark _tmp4_label3 = 0;
	static GQuark _tmp4_label4 = 0;
	static GQuark _tmp4_label5 = 0;
	static GQuark _tmp4_label6 = 0;
	static GQuark _tmp4_label7 = 0;
	static GQuark _tmp4_label8 = 0;
	static GQuark _tmp4_label9 = 0;
	static GQuark _tmp4_label10 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = _tmp0_->schema;
	_tmp2_ = _tmp1_->type;
	_tmp3_ = _tmp2_;
	_tmp5_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	if ((((((((_tmp5_ == ((0 != _tmp4_label0) ? _tmp4_label0 : (_tmp4_label0 = g_quark_from_static_string ("y")))) || (_tmp5_ == ((0 != _tmp4_label1) ? _tmp4_label1 : (_tmp4_label1 = g_quark_from_static_string ("n"))))) || (_tmp5_ == ((0 != _tmp4_label2) ? _tmp4_label2 : (_tmp4_label2 = g_quark_from_static_string ("q"))))) || (_tmp5_ == ((0 != _tmp4_label3) ? _tmp4_label3 : (_tmp4_label3 = g_quark_from_static_string ("i"))))) || (_tmp5_ == ((0 != _tmp4_label4) ? _tmp4_label4 : (_tmp4_label4 = g_quark_from_static_string ("u"))))) || (_tmp5_ == ((0 != _tmp4_label5) ? _tmp4_label5 : (_tmp4_label5 = g_quark_from_static_string ("x"))))) || (_tmp5_ == ((0 != _tmp4_label6) ? _tmp4_label6 : (_tmp4_label6 = g_quark_from_static_string ("t"))))) || (_tmp5_ == ((0 != _tmp4_label7) ? _tmp4_label7 : (_tmp4_label7 = g_quark_from_static_string ("d"))))) {
		switch (0) {
			default:
			{
				GVariant* min = NULL;
				GVariant* max = NULL;
				Key* _tmp6_;
				SchemaKey* _tmp7_;
				SchemaValueRange* _tmp8_;
				const gchar* _tmp23_ = NULL;
				GVariant* _tmp24_;
				gchar* _tmp25_ = NULL;
				gchar* _tmp26_;
				GVariant* _tmp27_;
				gchar* _tmp28_ = NULL;
				gchar* _tmp29_;
				gchar* _tmp30_ = NULL;
				gchar* _tmp31_;
				_tmp6_ = key;
				_tmp7_ = _tmp6_->schema;
				_tmp8_ = _tmp7_->range;
				if (_tmp8_ != NULL) {
					Key* _tmp9_;
					SchemaKey* _tmp10_;
					SchemaValueRange* _tmp11_;
					GVariant* _tmp12_;
					GVariant* _tmp13_;
					Key* _tmp14_;
					SchemaKey* _tmp15_;
					SchemaValueRange* _tmp16_;
					GVariant* _tmp17_;
					GVariant* _tmp18_;
					_tmp9_ = key;
					_tmp10_ = _tmp9_->schema;
					_tmp11_ = _tmp10_->range;
					_tmp12_ = _tmp11_->min;
					_tmp13_ = _g_variant_ref0 (_tmp12_);
					_g_variant_unref0 (min);
					min = _tmp13_;
					_tmp14_ = key;
					_tmp15_ = _tmp14_->schema;
					_tmp16_ = _tmp15_->range;
					_tmp17_ = _tmp16_->max;
					_tmp18_ = _g_variant_ref0 (_tmp17_);
					_g_variant_unref0 (max);
					max = _tmp18_;
				} else {
					Key* _tmp19_;
					GVariant* _tmp20_ = NULL;
					Key* _tmp21_;
					GVariant* _tmp22_ = NULL;
					_tmp19_ = key;
					_tmp20_ = key_get_min (_tmp19_);
					_g_variant_unref0 (min);
					min = _tmp20_;
					_tmp21_ = key;
					_tmp22_ = key_get_max (_tmp21_);
					_g_variant_unref0 (max);
					max = _tmp22_;
				}
				_tmp23_ = _ ("Integer [%s..%s]");
				_tmp24_ = min;
				_tmp25_ = g_variant_print (_tmp24_, FALSE);
				_tmp26_ = _tmp25_;
				_tmp27_ = max;
				_tmp28_ = g_variant_print (_tmp27_, FALSE);
				_tmp29_ = _tmp28_;
				_tmp30_ = g_strdup_printf (_tmp23_, _tmp26_, _tmp29_);
				_tmp31_ = _tmp30_;
				_g_free0 (_tmp29_);
				_g_free0 (_tmp26_);
				result = _tmp31_;
				_g_variant_unref0 (max);
				_g_variant_unref0 (min);
				return result;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label8) ? _tmp4_label8 : (_tmp4_label8 = g_quark_from_static_string ("b")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp32_ = NULL;
				gchar* _tmp33_;
				_tmp32_ = _ ("Boolean");
				_tmp33_ = g_strdup (_tmp32_);
				result = _tmp33_;
				return result;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label9) ? _tmp4_label9 : (_tmp4_label9 = g_quark_from_static_string ("s")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp34_ = NULL;
				gchar* _tmp35_;
				_tmp34_ = _ ("String");
				_tmp35_ = g_strdup (_tmp34_);
				result = _tmp35_;
				return result;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label10) ? _tmp4_label10 : (_tmp4_label10 = g_quark_from_static_string ("<enum>")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp36_ = NULL;
				gchar* _tmp37_;
				_tmp36_ = _ ("Enumeration");
				_tmp37_ = g_strdup (_tmp36_);
				result = _tmp37_;
				return result;
			}
		}
	} else {
		switch (0) {
			default:
			{
				Key* _tmp38_;
				SchemaKey* _tmp39_;
				const gchar* _tmp40_;
				gchar* _tmp41_;
				_tmp38_ = key;
				_tmp39_ = _tmp38_->schema;
				_tmp40_ = _tmp39_->type;
				_tmp41_ = g_strdup (_tmp40_);
				result = _tmp41_;
				return result;
			}
		}
	}
}


static void _configuration_editor_key_changed_cb_key_value_changed (Key* _sender, gpointer self) {
	configuration_editor_key_changed_cb (self, _sender);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static void configuration_editor_key_selected_cb (ConfigurationEditor* self) {
	Key* _tmp0_;
	GtkTreeIter iter = {0};
	GtkTreeModel* model = NULL;
	GtkTreeView* _tmp3_;
	GtkTreeSelection* _tmp4_ = NULL;
	GtkTreeModel* _tmp5_ = NULL;
	GtkTreeIter _tmp6_ = {0};
	gboolean _tmp7_ = FALSE;
	GtkTreeModel* _tmp8_;
	Key* _tmp14_;
	GtkGrid* _tmp16_;
	Key* _tmp17_;
	gboolean _tmp18_ = FALSE;
	Key* _tmp19_;
	GtkAction* _tmp23_;
	gboolean _tmp24_;
	gchar* _tmp25_;
	gchar* schema_name;
	gchar* _tmp26_;
	gchar* summary;
	gchar* _tmp27_;
	gchar* description;
	gchar* _tmp28_;
	gchar* type;
	gchar* _tmp29_;
	gchar* default_value;
	Key* _tmp30_;
	GtkLabel* _tmp60_;
	const gchar* _tmp61_;
	GtkLabel* _tmp62_;
	const gchar* _tmp63_;
	gchar* _tmp64_ = NULL;
	gchar* _tmp65_;
	GtkLabel* _tmp66_;
	const gchar* _tmp67_;
	gchar* _tmp68_ = NULL;
	gchar* _tmp69_;
	GtkLabel* _tmp70_;
	const gchar* _tmp71_;
	GtkLabel* _tmp72_;
	const gchar* _tmp73_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->selected_key;
	if (_tmp0_ != NULL) {
		Key* _tmp1_;
		guint _tmp2_ = 0U;
		_tmp1_ = self->priv->selected_key;
		g_signal_parse_name ("value-changed", TYPE_KEY, &_tmp2_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp1_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _configuration_editor_key_changed_cb_key_value_changed, self);
	}
	_tmp3_ = self->priv->key_tree_view;
	_tmp4_ = gtk_tree_view_get_selection (_tmp3_);
	_tmp7_ = gtk_tree_selection_get_selected (_tmp4_, &_tmp5_, &_tmp6_);
	_g_object_unref0 (model);
	_tmp8_ = _g_object_ref0 (_tmp5_);
	model = _tmp8_;
	iter = _tmp6_;
	if (_tmp7_) {
		GtkTreeModel* _tmp9_;
		KeyModel* _tmp10_;
		KeyModel* key_model;
		KeyModel* _tmp11_;
		GtkTreeIter _tmp12_;
		Key* _tmp13_ = NULL;
		_tmp9_ = model;
		_tmp10_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, TYPE_KEY_MODEL, KeyModel));
		key_model = _tmp10_;
		_tmp11_ = key_model;
		_tmp12_ = iter;
		_tmp13_ = key_model_get_key (_tmp11_, &_tmp12_);
		_g_object_unref0 (self->priv->selected_key);
		self->priv->selected_key = _tmp13_;
		_g_object_unref0 (key_model);
	} else {
		_g_object_unref0 (self->priv->selected_key);
		self->priv->selected_key = NULL;
	}
	_tmp14_ = self->priv->selected_key;
	if (_tmp14_ != NULL) {
		Key* _tmp15_;
		_tmp15_ = self->priv->selected_key;
		g_signal_connect_object (_tmp15_, "value-changed", (GCallback) _configuration_editor_key_changed_cb_key_value_changed, self, 0);
	}
	_tmp16_ = self->priv->key_info_grid;
	_tmp17_ = self->priv->selected_key;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp16_, _tmp17_ != NULL);
	_tmp19_ = self->priv->selected_key;
	if (_tmp19_ != NULL) {
		Key* _tmp20_;
		gboolean _tmp21_;
		gboolean _tmp22_;
		_tmp20_ = self->priv->selected_key;
		_tmp21_ = key_get_is_default (_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp18_ = !_tmp22_;
	} else {
		_tmp18_ = FALSE;
	}
	_tmp23_ = self->priv->set_default_action;
	_tmp24_ = _tmp18_;
	gtk_action_set_sensitive (_tmp23_, _tmp24_);
	_tmp25_ = g_strdup ("");
	schema_name = _tmp25_;
	_tmp26_ = g_strdup ("");
	summary = _tmp26_;
	_tmp27_ = g_strdup ("");
	description = _tmp27_;
	_tmp28_ = g_strdup ("");
	type = _tmp28_;
	_tmp29_ = g_strdup ("");
	default_value = _tmp29_;
	_tmp30_ = self->priv->selected_key;
	if (_tmp30_ != NULL) {
		Key* _tmp31_;
		SchemaKey* _tmp32_;
		_tmp31_ = self->priv->selected_key;
		_tmp32_ = _tmp31_->schema;
		if (_tmp32_ != NULL) {
			Key* _tmp33_;
			SchemaKey* _tmp34_;
			Schema* _tmp35_;
			const gchar* _tmp36_;
			gchar* _tmp37_;
			Key* _tmp38_;
			SchemaKey* _tmp39_;
			const gchar* _tmp40_;
			Key* _tmp45_;
			SchemaKey* _tmp46_;
			const gchar* _tmp47_;
			Key* _tmp52_;
			gchar* _tmp53_ = NULL;
			Key* _tmp54_;
			SchemaKey* _tmp55_;
			GVariant* _tmp56_;
			gchar* _tmp57_ = NULL;
			_tmp33_ = self->priv->selected_key;
			_tmp34_ = _tmp33_->schema;
			_tmp35_ = _tmp34_->schema;
			_tmp36_ = _tmp35_->id;
			_tmp37_ = g_strdup (_tmp36_);
			_g_free0 (schema_name);
			schema_name = _tmp37_;
			_tmp38_ = self->priv->selected_key;
			_tmp39_ = _tmp38_->schema;
			_tmp40_ = _tmp39_->summary;
			if (_tmp40_ != NULL) {
				Key* _tmp41_;
				SchemaKey* _tmp42_;
				const gchar* _tmp43_;
				gchar* _tmp44_;
				_tmp41_ = self->priv->selected_key;
				_tmp42_ = _tmp41_->schema;
				_tmp43_ = _tmp42_->summary;
				_tmp44_ = g_strdup (_tmp43_);
				_g_free0 (summary);
				summary = _tmp44_;
			}
			_tmp45_ = self->priv->selected_key;
			_tmp46_ = _tmp45_->schema;
			_tmp47_ = _tmp46_->description;
			if (_tmp47_ != NULL) {
				Key* _tmp48_;
				SchemaKey* _tmp49_;
				const gchar* _tmp50_;
				gchar* _tmp51_;
				_tmp48_ = self->priv->selected_key;
				_tmp49_ = _tmp48_->schema;
				_tmp50_ = _tmp49_->description;
				_tmp51_ = g_strdup (_tmp50_);
				_g_free0 (description);
				description = _tmp51_;
			}
			_tmp52_ = self->priv->selected_key;
			_tmp53_ = configuration_editor_key_to_description (self, _tmp52_);
			_g_free0 (type);
			type = _tmp53_;
			_tmp54_ = self->priv->selected_key;
			_tmp55_ = _tmp54_->schema;
			_tmp56_ = _tmp55_->default_value;
			_tmp57_ = g_variant_print (_tmp56_, FALSE);
			_g_free0 (default_value);
			default_value = _tmp57_;
		} else {
			const gchar* _tmp58_ = NULL;
			gchar* _tmp59_;
			_tmp58_ = _ ("No schema");
			_tmp59_ = g_strdup (_tmp58_);
			_g_free0 (schema_name);
			schema_name = _tmp59_;
		}
	}
	_tmp60_ = self->priv->schema_label;
	_tmp61_ = schema_name;
	gtk_label_set_text (_tmp60_, _tmp61_);
	_tmp62_ = self->priv->summary_label;
	_tmp63_ = summary;
	_tmp64_ = string_strip (_tmp63_);
	_tmp65_ = _tmp64_;
	gtk_label_set_text (_tmp62_, _tmp65_);
	_g_free0 (_tmp65_);
	_tmp66_ = self->priv->description_label;
	_tmp67_ = description;
	_tmp68_ = string_strip (_tmp67_);
	_tmp69_ = _tmp68_;
	gtk_label_set_text (_tmp66_, _tmp69_);
	_g_free0 (_tmp69_);
	_tmp70_ = self->priv->type_label;
	_tmp71_ = type;
	gtk_label_set_text (_tmp70_, _tmp71_);
	_tmp72_ = self->priv->default_label;
	_tmp73_ = default_value;
	gtk_label_set_text (_tmp72_, _tmp73_);
	_g_free0 (default_value);
	_g_free0 (type);
	_g_free0 (description);
	_g_free0 (summary);
	_g_free0 (schema_name);
	_g_object_unref0 (model);
}


static void configuration_editor_key_changed_cb (ConfigurationEditor* self, Key* key) {
	gboolean _tmp0_ = FALSE;
	Key* _tmp1_;
	GtkAction* _tmp5_;
	gboolean _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_tmp1_ = self->priv->selected_key;
	if (_tmp1_ != NULL) {
		Key* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp2_ = self->priv->selected_key;
		_tmp3_ = key_get_is_default (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = self->priv->set_default_action;
	_tmp6_ = _tmp0_;
	gtk_action_set_sensitive (_tmp5_, _tmp6_);
}


static void configuration_editor_set_default_cb (ConfigurationEditor* self, GtkAction* action) {
	Key* _tmp0_;
	Key* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->priv->selected_key;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->priv->selected_key;
	key_set_to_default (_tmp1_);
}


static gboolean configuration_editor_main_window_configure_event_cb (ConfigurationEditor* self, GtkWidget* widget, GdkEventConfigure* event) {
	gboolean result = FALSE;
	GSettings* _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->settings;
	_tmp1_ = g_settings_get_boolean (_tmp0_, "maximized");
	if (!_tmp1_) {
		GSettings* _tmp2_;
		GdkEventConfigure _tmp3_;
		gint _tmp4_;
		GSettings* _tmp5_;
		GdkEventConfigure _tmp6_;
		gint _tmp7_;
		_tmp2_ = self->priv->settings;
		_tmp3_ = *event;
		_tmp4_ = _tmp3_.width;
		g_settings_set_int (_tmp2_, "width", _tmp4_);
		_tmp5_ = self->priv->settings;
		_tmp6_ = *event;
		_tmp7_ = _tmp6_.height;
		g_settings_set_int (_tmp5_, "height", _tmp7_);
	}
	result = FALSE;
	return result;
}


static gboolean configuration_editor_main_window_window_state_event_cb (ConfigurationEditor* self, GtkWidget* widget, GdkEventWindowState* event) {
	gboolean result = FALSE;
	GdkEventWindowState _tmp0_;
	GdkWindowState _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.changed_mask;
	if ((_tmp1_ & GDK_WINDOW_STATE_MAXIMIZED) != 0) {
		GdkEventWindowState _tmp2_;
		GdkWindowState _tmp3_;
		gboolean is_maximized;
		GSettings* _tmp4_;
		gboolean _tmp5_;
		_tmp2_ = *event;
		_tmp3_ = _tmp2_.new_window_state;
		is_maximized = (_tmp3_ & GDK_WINDOW_STATE_MAXIMIZED) != 0;
		_tmp4_ = self->priv->settings;
		_tmp5_ = is_maximized;
		g_settings_set_boolean (_tmp4_, "maximized", _tmp5_);
	}
	result = FALSE;
	return result;
}


static void configuration_editor_find_cb (ConfigurationEditor* self) {
	GtkBox* _tmp0_;
	GtkEntry* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->search_box;
	gtk_widget_show ((GtkWidget*) _tmp0_);
	_tmp1_ = self->priv->search_entry;
	gtk_widget_grab_focus ((GtkWidget*) _tmp1_);
}


static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _result_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static void configuration_editor_find_next_cb (ConfigurationEditor* self) {
	GtkLabel* _tmp0_;
	GtkTreeIter iter = {0};
	GtkTreeIter key_iter = {0};
	gboolean have_key_iter;
	GtkTreeView* _tmp1_;
	GtkTreeSelection* _tmp2_ = NULL;
	GtkTreeIter _tmp3_ = {0};
	gboolean _tmp4_ = FALSE;
	GtkLabel* _tmp72_;
	const gchar* _tmp73_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->search_label;
	gtk_label_set_text (_tmp0_, "");
	memset (&key_iter, 0, sizeof (GtkTreeIter));
	have_key_iter = FALSE;
	_tmp1_ = self->priv->dir_tree_view;
	_tmp2_ = gtk_tree_view_get_selection (_tmp1_);
	_tmp4_ = gtk_tree_selection_get_selected (_tmp2_, NULL, &_tmp3_);
	iter = _tmp3_;
	if (_tmp4_) {
		GtkTreeView* _tmp5_;
		GtkTreeSelection* _tmp6_ = NULL;
		GtkTreeIter _tmp7_ = {0};
		gboolean _tmp8_ = FALSE;
		_tmp5_ = self->priv->key_tree_view;
		_tmp6_ = gtk_tree_view_get_selection (_tmp5_);
		_tmp8_ = gtk_tree_selection_get_selected (_tmp6_, NULL, &_tmp7_);
		key_iter = _tmp7_;
		if (_tmp8_) {
			SettingsModel* _tmp9_;
			GtkTreeIter _tmp10_;
			Directory* _tmp11_ = NULL;
			Directory* dir;
			Directory* _tmp12_;
			KeyModel* _tmp13_;
			KeyModel* _tmp14_;
			gboolean _tmp15_ = FALSE;
			_tmp9_ = self->priv->model;
			_tmp10_ = iter;
			_tmp11_ = settings_model_get_directory (_tmp9_, &_tmp10_);
			dir = _tmp11_;
			_tmp12_ = dir;
			_tmp13_ = directory_get_key_model (_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = gtk_tree_model_iter_next ((GtkTreeModel*) _tmp14_, &key_iter);
			if (_tmp15_) {
				have_key_iter = TRUE;
			} else {
				configuration_editor_get_next_iter (self, &iter);
			}
			_g_object_unref0 (dir);
		}
	} else {
		SettingsModel* _tmp16_;
		GtkTreeIter _tmp17_ = {0};
		gboolean _tmp18_ = FALSE;
		_tmp16_ = self->priv->model;
		_tmp18_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) _tmp16_, &_tmp17_);
		iter = _tmp17_;
		if (!_tmp18_) {
			return;
		}
	}
	{
		gboolean _tmp19_;
		_tmp19_ = TRUE;
		while (TRUE) {
			gboolean _tmp20_;
			SettingsModel* _tmp22_;
			GtkTreeIter _tmp23_;
			Directory* _tmp24_ = NULL;
			Directory* dir;
			gboolean _tmp25_;
			gboolean _tmp31_;
			_tmp20_ = _tmp19_;
			if (!_tmp20_) {
				gboolean _tmp21_ = FALSE;
				_tmp21_ = configuration_editor_get_next_iter (self, &iter);
				if (!_tmp21_) {
					break;
				}
			}
			_tmp19_ = FALSE;
			_tmp22_ = self->priv->model;
			_tmp23_ = iter;
			_tmp24_ = settings_model_get_directory (_tmp22_, &_tmp23_);
			dir = _tmp24_;
			_tmp25_ = have_key_iter;
			if (!_tmp25_) {
				Directory* _tmp26_;
				KeyModel* _tmp27_;
				KeyModel* _tmp28_;
				GtkTreeIter _tmp29_ = {0};
				gboolean _tmp30_ = FALSE;
				_tmp26_ = dir;
				_tmp27_ = directory_get_key_model (_tmp26_);
				_tmp28_ = _tmp27_;
				_tmp30_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) _tmp28_, &_tmp29_);
				key_iter = _tmp29_;
				have_key_iter = _tmp30_;
			}
			_tmp31_ = have_key_iter;
			if (_tmp31_) {
				{
					gboolean _tmp32_;
					_tmp32_ = TRUE;
					while (TRUE) {
						gboolean _tmp33_;
						Directory* _tmp38_;
						KeyModel* _tmp39_;
						KeyModel* _tmp40_;
						GtkTreeIter _tmp41_;
						Key* _tmp42_ = NULL;
						Key* key;
						Key* _tmp43_;
						const gchar* _tmp44_;
						GtkEntry* _tmp45_;
						const gchar* _tmp46_;
						const gchar* _tmp47_;
						gint _tmp48_ = 0;
						_tmp33_ = _tmp32_;
						if (!_tmp33_) {
							Directory* _tmp34_;
							KeyModel* _tmp35_;
							KeyModel* _tmp36_;
							gboolean _tmp37_ = FALSE;
							_tmp34_ = dir;
							_tmp35_ = directory_get_key_model (_tmp34_);
							_tmp36_ = _tmp35_;
							_tmp37_ = gtk_tree_model_iter_next ((GtkTreeModel*) _tmp36_, &key_iter);
							if (!_tmp37_) {
								break;
							}
						}
						_tmp32_ = FALSE;
						_tmp38_ = dir;
						_tmp39_ = directory_get_key_model (_tmp38_);
						_tmp40_ = _tmp39_;
						_tmp41_ = key_iter;
						_tmp42_ = key_model_get_key (_tmp40_, &_tmp41_);
						key = _tmp42_;
						_tmp43_ = key;
						_tmp44_ = _tmp43_->name;
						_tmp45_ = self->priv->search_entry;
						_tmp46_ = gtk_entry_get_text (_tmp45_);
						_tmp47_ = _tmp46_;
						_tmp48_ = string_index_of (_tmp44_, _tmp47_, 0);
						if (_tmp48_ >= 0) {
							GtkTreeView* _tmp49_;
							SettingsModel* _tmp50_;
							GtkTreeIter _tmp51_;
							GtkTreePath* _tmp52_ = NULL;
							GtkTreePath* _tmp53_;
							GtkTreeView* _tmp54_;
							GtkTreeSelection* _tmp55_ = NULL;
							GtkTreeIter _tmp56_;
							GtkTreeView* _tmp57_;
							SettingsModel* _tmp58_;
							GtkTreeIter _tmp59_;
							GtkTreePath* _tmp60_ = NULL;
							GtkTreePath* _tmp61_;
							GtkTreeView* _tmp62_;
							GtkTreeSelection* _tmp63_ = NULL;
							GtkTreeIter _tmp64_;
							GtkTreeView* _tmp65_;
							Directory* _tmp66_;
							KeyModel* _tmp67_;
							KeyModel* _tmp68_;
							GtkTreeIter _tmp69_;
							GtkTreePath* _tmp70_ = NULL;
							GtkTreePath* _tmp71_;
							_tmp49_ = self->priv->dir_tree_view;
							_tmp50_ = self->priv->model;
							_tmp51_ = iter;
							_tmp52_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp50_, &_tmp51_);
							_tmp53_ = _tmp52_;
							gtk_tree_view_expand_to_path (_tmp49_, _tmp53_);
							_gtk_tree_path_free0 (_tmp53_);
							_tmp54_ = self->priv->dir_tree_view;
							_tmp55_ = gtk_tree_view_get_selection (_tmp54_);
							_tmp56_ = iter;
							gtk_tree_selection_select_iter (_tmp55_, &_tmp56_);
							_tmp57_ = self->priv->dir_tree_view;
							_tmp58_ = self->priv->model;
							_tmp59_ = iter;
							_tmp60_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp58_, &_tmp59_);
							_tmp61_ = _tmp60_;
							gtk_tree_view_scroll_to_cell (_tmp57_, _tmp61_, NULL, FALSE, (gfloat) 0, (gfloat) 0);
							_gtk_tree_path_free0 (_tmp61_);
							_tmp62_ = self->priv->key_tree_view;
							_tmp63_ = gtk_tree_view_get_selection (_tmp62_);
							_tmp64_ = key_iter;
							gtk_tree_selection_select_iter (_tmp63_, &_tmp64_);
							_tmp65_ = self->priv->key_tree_view;
							_tmp66_ = dir;
							_tmp67_ = directory_get_key_model (_tmp66_);
							_tmp68_ = _tmp67_;
							_tmp69_ = key_iter;
							_tmp70_ = gtk_tree_model_get_path ((GtkTreeModel*) _tmp68_, &_tmp69_);
							_tmp71_ = _tmp70_;
							gtk_tree_view_scroll_to_cell (_tmp65_, _tmp71_, NULL, FALSE, (gfloat) 0, (gfloat) 0);
							_gtk_tree_path_free0 (_tmp71_);
							_g_object_unref0 (key);
							_g_object_unref0 (dir);
							return;
						}
						_g_object_unref0 (key);
					}
				}
			}
			have_key_iter = FALSE;
			_g_object_unref0 (dir);
		}
	}
	_tmp72_ = self->priv->search_label;
	_tmp73_ = _ ("Not found");
	gtk_label_set_text (_tmp72_, _tmp73_);
}


static gboolean configuration_editor_get_next_iter (ConfigurationEditor* self, GtkTreeIter* iter) {
	gboolean result = FALSE;
	SettingsModel* _tmp0_;
	GtkTreeIter _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (iter != NULL, FALSE);
	_tmp0_ = self->priv->model;
	_tmp1_ = *iter;
	_tmp2_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) _tmp0_, &_tmp1_);
	if (_tmp2_) {
		SettingsModel* _tmp3_;
		GtkTreeIter _tmp4_;
		GtkTreeIter _tmp5_ = {0};
		_tmp3_ = self->priv->model;
		_tmp4_ = *iter;
		gtk_tree_model_iter_nth_child ((GtkTreeModel*) _tmp3_, &_tmp5_, &_tmp4_, 0);
		*iter = _tmp5_;
		result = TRUE;
		return result;
	}
	while (TRUE) {
		SettingsModel* _tmp6_;
		gboolean _tmp7_ = FALSE;
		SettingsModel* _tmp8_;
		GtkTreeIter _tmp9_;
		GtkTreeIter _tmp10_ = {0};
		gboolean _tmp11_ = FALSE;
		_tmp6_ = self->priv->model;
		_tmp7_ = gtk_tree_model_iter_next ((GtkTreeModel*) _tmp6_, iter);
		if (!(!_tmp7_)) {
			break;
		}
		_tmp8_ = self->priv->model;
		_tmp9_ = *iter;
		_tmp11_ = gtk_tree_model_iter_parent ((GtkTreeModel*) _tmp8_, &_tmp10_, &_tmp9_);
		*iter = _tmp10_;
		if (!_tmp11_) {
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


static void configuration_editor_about_cb (ConfigurationEditor* self) {
	gchar* _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** authors;
	gint authors_length1;
	gint _authors_size_;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* license;
	GtkApplicationWindow* _tmp4_;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("Robert Ancell");
	_tmp1_ = g_new0 (gchar*, 2 + 1);
	_tmp1_[0] = _tmp0_;
	_tmp1_[1] = NULL;
	authors = _tmp1_;
	authors_length1 = 2;
	_authors_size_ = authors_length1;
	_tmp2_ = _ ("This program is free software; you can redistribute it and/or modify i" \
"t under the terms of the GNU General Public License as published by th" \
"e Free Software Foundation; either version 2 of the License, or (at yo" \
"ur option) any later version.\n" \
"\n" \
"This program is distributed in the hope that it will be useful, but WI" \
"THOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILI" \
"TY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public Li" \
"cense for more details.\n" \
"\n" \
"You should have received a copy of the GNU General Public License alon" \
"g with this program; if not, write to the Free Software Foundation, In" \
"c., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA");
	_tmp3_ = g_strdup (_tmp2_);
	license = _tmp3_;
	_tmp4_ = self->priv->window;
	_tmp5_ = _ ("dconf Editor");
	_tmp6_ = _ ("Directly edit your entire configuration database");
	_tmp7_ = _ ("Copyright \xc2\xa9 Canonical Ltd");
	_tmp8_ = _ ("translator-credits");
	gtk_show_about_dialog ((GtkWindow*) _tmp4_, "program-name", _tmp5_, "version", VERSION, "comments", _tmp6_, "copyright", _tmp7_, "license", license, "wrap-license", TRUE, "authors", authors, "translator-credits", _tmp8_, "logo-icon-name", "dconf-editor", NULL, NULL);
	_g_free0 (license);
	authors = (_vala_array_free (authors, authors_length1, (GDestroyNotify) g_free), NULL);
}


static void configuration_editor_quit_cb (ConfigurationEditor* self) {
	GtkApplicationWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->window;
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
}


gint configuration_editor_main (gchar** args, int args_length1) {
	gint result = 0;
	ConfigurationEditor* _tmp0_;
	ConfigurationEditor* app;
	gchar** _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_ = 0;
	setlocale (LC_ALL, "");
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	_tmp0_ = configuration_editor_new ();
	app = _tmp0_;
	_tmp1_ = args;
	_tmp1__length1 = args_length1;
	_tmp2_ = g_application_run ((GApplication*) app, _tmp1__length1, _tmp1_);
	result = _tmp2_;
	_g_object_unref0 (app);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return configuration_editor_main (argv, argc);
}


static void configuration_editor_class_init (ConfigurationEditorClass * klass) {
	configuration_editor_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ConfigurationEditorPrivate));
	G_APPLICATION_CLASS (klass)->startup = configuration_editor_real_startup;
	G_APPLICATION_CLASS (klass)->activate = configuration_editor_real_activate;
	G_OBJECT_CLASS (klass)->finalize = configuration_editor_finalize;
}


static void configuration_editor_instance_init (ConfigurationEditor * self) {
	self->priv = CONFIGURATION_EDITOR_GET_PRIVATE (self);
}


static void configuration_editor_finalize (GObject* obj) {
	ConfigurationEditor * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CONFIGURATION_EDITOR, ConfigurationEditor);
	_g_object_unref0 (self->priv->model);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->ui);
	_g_object_unref0 (self->priv->window);
	_g_object_unref0 (self->priv->dir_tree_view);
	_g_object_unref0 (self->priv->key_tree_view);
	_g_object_unref0 (self->priv->key_info_grid);
	_g_object_unref0 (self->priv->schema_label);
	_g_object_unref0 (self->priv->summary_label);
	_g_object_unref0 (self->priv->description_label);
	_g_object_unref0 (self->priv->type_label);
	_g_object_unref0 (self->priv->default_label);
	_g_object_unref0 (self->priv->set_default_action);
	_g_object_unref0 (self->priv->search_box);
	_g_object_unref0 (self->priv->search_entry);
	_g_object_unref0 (self->priv->search_label);
	_g_object_unref0 (self->priv->selected_key);
	G_OBJECT_CLASS (configuration_editor_parent_class)->finalize (obj);
}


GType configuration_editor_get_type (void) {
	static volatile gsize configuration_editor_type_id__volatile = 0;
	if (g_once_init_enter (&configuration_editor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConfigurationEditorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) configuration_editor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConfigurationEditor), 0, (GInstanceInitFunc) configuration_editor_instance_init, NULL };
		GType configuration_editor_type_id;
		configuration_editor_type_id = g_type_register_static (GTK_TYPE_APPLICATION, "ConfigurationEditor", &g_define_type_info, 0);
		g_once_init_leave (&configuration_editor_type_id__volatile, configuration_editor_type_id);
	}
	return configuration_editor_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



